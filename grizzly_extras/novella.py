import logging
import re

from typing import Any, Dict, List, Union, Optional, NamedTuple, Callable, Match, cast
from pathlib import Path
from enum import Enum
from dataclasses import dataclass
from tokenize import tokenize, TokenInfo, TokenError
from token import OP, STRING
from io import BytesIO
from ast import literal_eval

import frontmatter
import mistune

from novella.markdown.preprocessor import MarkdownPreprocessor, MarkdownFiles, MarkdownFile
from novella.novella import NovellaContext
from novella.templates.mkdocs import MkdocsTemplate, MkdocsUpdateConfigAction
from novella.markdown.flavor import MkDocsFlavor
from novella.action import CopyFilesAction, RunAction
from novella.markdown.tags.anchor import AnchorTagProcessor
from novella.markdown.preprocessor import MarkdownPreprocessorAction
from pydoc_markdown.novella.preprocessor import PydocTagPreprocessor
from pydoc_markdown.contrib.renderers.markdown import MarkdownRenderer as PydocMarkdownRenderer
from mistune.renderers.markdown import MarkdownRenderer
from mistune.inline_parser import InlineParser
from mistune.core import BlockState, InlineState


logger = logging.getLogger('grizzly.novella')


class GrizzlyMkdocsTemplate(MkdocsTemplate):
    def define_pipeline(self, context: NovellaContext) -> None:
        context.option("serve", description="Use mkdocs serve", flag=True)
        context.option("port", description="The port to serve under", default="8000")
        context.option("site-dir", description='Build directory for MkDocs (defaults to "_site")', default="_site", metavar='PATH')
        context.option("base-url", description='The base URL to prefix to autogenerated link inside the documentation.', metavar='URL')

        copy_files = cast(CopyFilesAction, context.do('copy-files', name='copy-files'))
        copy_files.paths = [self.content_directory]

        for extension in ['yml', 'yaml']:
            if (context.project_directory / f'mkdocs.{extension}').exists():
                copy_files.paths.append(f'mkdocs.{extension}')
                break

        update_config = cast(MkdocsUpdateConfigAction, context.do('mkdocs-update-config', name='mkdocs-update-config'))
        update_config.content_directory = self.content_directory

        preprocessor = cast(MarkdownPreprocessorAction, context.do('preprocess-markdown', name='preprocess-markdown'))
        preprocessor.path = self.content_directory
        preprocessor.use('grizzly')

        def configure_anchor(anchor: AnchorTagProcessor) -> None:
            anchor.flavor = MkDocsFlavor(cast('str | None', context.options['base-url']) or self.base_url or '')

        context.delay(lambda: preprocessor.preprocessor('anchor', cast(Any, configure_anchor)))
        context.delay(lambda: preprocessor.preprocessor('grizzly'))

        def configure_run(run: RunAction) -> None:
            run.args = ['mkdocs']
            if context.options['serve']:
                port = int(str(context.options['port']))
                run.supports_reloading = True
                run.args += ['serve', '--dev-addr', f'localhost:{port}']
            else:
                run.args += ['build', '-d', context.project_directory / str(context.options['site-dir'])]
        context.do('run', configure_run, name='mkdocs-run')


class MarkdownAstType(Enum):
    TEXT = 'text'
    PARAGRAPH = 'paragraph'
    HEADER = 'heading'
    CODE_BLOCK = 'block_code'
    BLANK_LINE = 'blank_line'
    INLINE_HTML = 'inline_html'
    LINK = 'link'
    STRONG = 'strong'
    LIST = 'list'
    IMAGE = 'image'
    CODEPSPAN = 'codespan'
    BLOCK_QUOTE = 'block_quote'

    @classmethod
    def from_value(cls, value: str) -> 'MarkdownAstType':
        for enum_value in cls:
            if enum_value.value == value:
                return enum_value

        raise ValueError(f'"{value}" is not a valid value of {cls.__name__}')


@dataclass
class MarkdownAstNode:
    ast: Dict[str, Any]
    index: int

    @property
    def first_child(self) -> 'MarkdownAstNode':
        return MarkdownAstNode(self.ast.get('children', [{}])[0], self.index)

    @property
    def type(self) -> MarkdownAstType:
        return MarkdownAstType.from_value(self.ast.get('type', None))

    @property
    def raw(self) -> Optional[str]:
        return cast(Optional[str], self.ast.get('raw', None))


class MarkdownHeading(NamedTuple):
    text: str
    level: int


class Continue(Exception):
    pass


class Break(Exception):
    pass


def make_human_readable(input: str) -> str:
    words: List[str] = []

    for word in input.split('_'):
        words.append(word.capitalize())

    output = ' '.join(words)

    for word in ['http', 'sftp', 'api', 'csv']:
        output = output.replace(word.capitalize(), word.upper())
        output = output.replace(word, word.upper())

    to_replace = dict(Iot='IoT', hub='Hub')
    for value, replace_value in to_replace.items():
        output = output.replace(value, replace_value)

    return output


def _create_nav_node(target: List[Union[str, Dict[str, str]]], path: str, node: Path) -> None:
    if not (node.is_file() and (node.stem == '__init__' or not node.stem.startswith('_'))):
        return

    if node.stem == '__init__':
        target.insert(0, f'{path}/index.md')
    else:
        target.append({make_human_readable(node.stem): f'{path}/{node.stem}.md'})


def mkdocs_update_config(config: Dict[str, Any]) -> None:
    root = Path.cwd().parent
    config_nav_tasks = config['nav'][3]['Framework'][0]['Usage'][0]['Tasks']
    config_nav_tasks_clients = config_nav_tasks.pop()
    tasks = root / 'grizzly' / 'tasks'

    nav_tasks: List[Union[str, Dict[str, str]]] = []
    for task in tasks.iterdir():
        _create_nav_node(nav_tasks, 'framework/usage/tasks', task)
    config_nav_tasks.extend(nav_tasks)

    tasks_clients = tasks / 'clients'
    nav_tasks_clients: List[Union[str, Dict[str, str]]] = []
    for task_client in tasks_clients.iterdir():
        _create_nav_node(nav_tasks_clients, 'framework/usage/tasks/clients', task_client)
    config_nav_tasks_clients['Clients'] = nav_tasks_clients
    config_nav_tasks.append(config_nav_tasks_clients)

    config_nav_testdata = config['nav'][3]['Framework'][0]['Usage'][1]['Variables'][1]
    nav_testdata: List[Union[str, Dict[str, str]]] = []
    variables = Path.cwd() / '..' / 'grizzly' / 'testdata' / 'variables'
    for variable in variables.iterdir():
        _create_nav_node(nav_testdata, 'framework/usage/variables/testdata', variable)
    config_nav_testdata['Testdata'] = nav_testdata

    config_nav_users = config['nav'][3]['Framework'][0]['Usage'][2]
    users = root / 'grizzly' / 'users'
    nav_users: List[Union[str, Dict[str, str]]] = []
    for user in users.iterdir():
        _create_nav_node(nav_users, 'framework/usage/load-users', user)

    config_nav_users['Load Users'] = nav_users

    config_nav_steps = config['nav'][3]['Framework'][0]['Usage'][3]['Steps']
    steps = root / 'grizzly' / 'steps'
    for step in steps.iterdir():
        _create_nav_node(config_nav_steps, 'framework/usage/steps', step)

    config_nav_steps_background = config_nav_steps[1]
    steps_background = steps / 'background'
    nav_steps_background: List[Union[str, Dict[str, str]]] = []
    for step in steps_background.iterdir():
        _create_nav_node(nav_steps_background, 'framework/usage/steps/background', step)

    config_nav_steps_background['Background'] = nav_steps_background

    config_nav_steps_scenario = config_nav_steps[2]
    steps_scenario = steps / 'scenario'
    nav_steps_scenario: List[Union[str, Dict[str, str]]] = []
    for step in steps_scenario.iterdir():
        _create_nav_node(nav_steps_scenario, 'framework/usage/steps/scenario', step)

    config_nav_steps_scenario['Scenario'] = nav_steps_scenario


def preprocess_markdown_update_with_header_levels(processor: MarkdownPreprocessor, levels: Dict[str, int]) -> None:
    if isinstance(processor, PydocTagPreprocessor) and isinstance(processor._renderer, PydocMarkdownRenderer):
        processor._renderer.header_level_by_type.update(levels)


def _generate_dynamic_page(input_file: Path, output_path: Path, title: str, namespace: str) -> None:
    if not (input_file.is_file() and (input_file.stem == '__init__' or not input_file.stem.startswith('_'))):
        return

    if input_file.stem == '__init__':
        filename = 'index'
    else:
        filename = input_file.stem
        title = f'{title} / {make_human_readable(input_file.stem)}'
        namespace = f'{namespace}.{input_file.stem}'

    file = output_path / f'{filename}.md'
    file.parent.mkdir(parents=True, exist_ok=True)
    if not file.exists():
        file.write_text(f'''---
title: {title}
---
@pydoc {namespace}
''')


def generate_dynamic_pages(directory: Path) -> None:
    root = Path.cwd().parent

    tasks = root / 'grizzly' / 'tasks'
    output_path = directory / 'content' / 'framework' / 'usage' / 'tasks'
    for task in tasks.iterdir():
        _generate_dynamic_page(task, output_path, 'Tasks', 'grizzly.tasks')

    tasks_clients = tasks / 'clients'
    output_path = directory / 'content' / 'framework' / 'usage' / 'tasks' / 'clients'
    for task_client in tasks_clients.iterdir():
        _generate_dynamic_page(task_client, output_path, 'Clients', 'grizzly.tasks.clients')

    variables = root / 'grizzly' / 'testdata' / 'variables'
    output_path = directory / 'content' / 'framework' / 'usage' / 'variables' / 'testdata'
    for variable in variables.iterdir():
        _generate_dynamic_page(variable, output_path, 'Testdata', 'grizzly.testdata.variables')

    steps = root / 'grizzly' / 'steps'
    output_path = directory / 'content' / 'framework' / 'usage' / 'steps'
    for step in steps.iterdir():
        _generate_dynamic_page(step, output_path, 'Steps', 'grizzly.steps')

    steps_background = steps / 'background'
    output_path = directory / 'content' / 'framework' / 'usage' / 'steps' / 'background'
    for step in steps_background.iterdir():
        _generate_dynamic_page(step, output_path, 'Steps / Background', 'grizzly.steps.background')

    steps_scenario = steps / 'scenario'
    output_path = directory / 'content' / 'framework' / 'usage' / 'steps' / 'scenario'
    for step in steps_scenario.iterdir():
        _generate_dynamic_page(step, output_path, 'Steps / Scenario', 'grizzly.steps.scenario')

    users = root / 'grizzly' / 'users'
    output_path = directory / 'content' / 'framework' / 'usage' / 'load-users'
    for user in users.iterdir():
        _generate_dynamic_page(user, output_path, 'Load Users', 'grizzly.users')


class GrizzlyMarkdownInlineParser(InlineParser):
    def parse_codespan(self, match: Match, state: InlineState) -> int:
        """
        Default `mistune.inline_parser.InlineParser.parse_codespan` escapes code, which messes
        things up, it will escape some character to their HTML entity representation, which will be literal
        when rendering as HTML (& -> &amp; etc.).
        """
        marker = match.group(0)
        # require same marker with same length at end

        pattern = re.compile(r'(.*?[^`])' + marker + r'(?!`)', re.S)

        pos = match.end()
        m = pattern.match(state.src, pos)
        if m:
            end_pos = m.end()
            code = m.group(1)
            # Line endings are treated like spaces
            code = code.replace('\n', ' ')
            if len(code.strip()):
                if code.startswith(' ') and code.endswith(' '):
                    code = code[1:-1]
            state.append_token({'type': 'codespan', 'raw': code})
            return end_pos
        else:
            state.append_token({'type': 'text', 'raw': marker})
            return pos


class GrizzlyMarkdown:
    _markdown: mistune.Markdown
    _document: MarkdownFile
    _ast_tree: List[Dict[str, Any]]
    _index: int

    def __init__(self, markdown: mistune.Markdown, document: MarkdownFile) -> None:
        self._markdown = markdown
        self._document = document
        self._index = 0

    @classmethod
    def _is_anchor(cls, value: str) -> bool:
        return value.startswith('@anchor')

    @classmethod
    def _get_header(cls, node: MarkdownAstNode) -> MarkdownHeading:
        text = ''.join([child.get('raw', '') for child in node.ast.get('children', [])])
        level = node.ast.get('attrs', {}).get('level', 0)

        return MarkdownHeading(text, level)

    @property
    def node(self) -> MarkdownAstNode:
        return MarkdownAstNode(self._ast_tree[self._index], self._index)

    @property
    def next_node(self) -> MarkdownAstNode:
        try:
            return MarkdownAstNode(self._ast_tree[self._index + 1], self._index + 1)
        except IndexError:
            raise Break(self.node)

    def get_node(self, index: int) -> MarkdownAstNode:
        return MarkdownAstNode(self._ast_tree[index], index)

    def get_code_block(self, start_node: MarkdownAstNode) -> str:
        code_block = ''

        for index in range(start_node.index + 1, len(self._ast_tree)):
            node = MarkdownAstNode(self._ast_tree[index], index)

            if node.type == MarkdownAstType.CODE_BLOCK and node.raw is not None:
                code_block = node.raw
                self.index = index
                break

        return code_block

    @classmethod
    def _get_tokens(cls, text: str) -> List[TokenInfo]:
        tokens: List[TokenInfo] = []

        try:
            for token in tokenize(BytesIO(text.encode('utf8')).readline):
                tokens.append(token)
        except TokenError as e:
            if 'EOF in multi-line statement' not in str(e):
                raise

        return tokens

    def _remove(self, condition: Callable[[MarkdownAstNode], bool]) -> None:
        while condition(self.next_node):
            self._index += 1

    @classmethod
    def get_step_expression_from_code_block(cls, code_block: str) -> Optional[str]:
        tokens = cls._get_tokens(code_block)

        for index, token in enumerate(tokens):
            if token.type == OP and token.string == '@':
                future_index = index + 2
                future_token = tokens[future_index]

                if not (future_token.type == OP and future_token.string == '('):
                    continue

                future_index += 1

                while not (future_token.type == OP and future_token.string == ')') and future_index < len(tokens):
                    future_token = tokens[future_index]
                    if future_token.type == STRING:
                        return cast(Optional[str], literal_eval(future_token.string))

                    future_index += 1

        return None

    def _process_content(self, content: str) -> str:
        self._ast_tree = self._markdown(content)
        ast_modified: List[Dict[str, Any]] = []

        import json

        if '<condition>' in content:
            Path('ast.txt').write_text(json.dumps(self._ast_tree, indent=2))

        # logger.info(f'analyzing {len(self._ast_tree)} nodes')
        while self._index < len(self._ast_tree):
            try:
                if self.node.raw is not None and 'condition' in self.node.raw:
                    print(self.node.ast)

                if self.node.type == MarkdownAstType.PARAGRAPH:
                    if not self.node.first_child.type == MarkdownAstType.TEXT:
                        raise Continue()

                    text = self.node.first_child.raw

                    if text is None:
                        raise Continue()

                    if self._is_anchor(text):
                        if not self.next_node.type == MarkdownAstType.HEADER:
                            raise Continue()

                        header = self._get_header(self.next_node)

                        # remove all text under "Class " headers
                        if header.level == 2 and header.text.startswith('Class '):
                            def condition(node: MarkdownAstNode) -> bool:
                                return not node.type == MarkdownAstType.PARAGRAPH and not node.type == MarkdownAstType.HEADER

                            self._remove(condition)

                            raise Continue()

                        # rewrite
                        code_block = self.get_code_block(self.next_node)
                        ast_modified.append(self.node.ast)
                        new_header = self.get_step_expression_from_code_block(code_block)

                        if new_header is not None:
                            ast_modified.extend(self._markdown(f'{"#" * header.level} {new_header}'))
            except Continue:
                continue
            except Break:
                break
            except IndexError:
                pass
            finally:
                ast_modified.append(self.node.ast)
                self._index += 1

        renderer = MarkdownRenderer()

        content = cast(str, renderer(ast_modified, state=BlockState()))

        return content

    def __call__(self) -> None:
        content = self._document.content

        if not frontmatter.checks(content):
            content = self._process_content(content)
        else:
            frontmatter_document = frontmatter.loads(content)
            frontmatter_document.content = self._process_content(frontmatter_document.content)
            content = cast(str, frontmatter.dumps(frontmatter_document))

        self._document.content = content


class GrizzlyMarkdownProcessor(MarkdownPreprocessor):
    _markdown: mistune.Markdown

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)

        self._markdown = mistune.Markdown(inline=GrizzlyMarkdownInlineParser())

    def process_files(self, files: MarkdownFiles) -> None:
        for file in files:
            GrizzlyMarkdown(self._markdown, file)()


if __name__ == '__main__':
    file = Path('debug.md')

    assert file.exists()

    markdown_file = MarkdownFile(Path.cwd() / 'in.md', Path.cwd() / 'out.md', file.read_text())

    GrizzlyMarkdown(markdown=mistune.create_markdown(renderer='ast'), document=markdown_file)()
