{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Grizzly - /\u02c8\u0261\u0279\u026azli/ Grizzly is a framework to be able to easily define load scenarios, and is mainly built on-top of two other frameworks: Locust : Define user behaviour with Python code, and swarm your system with millions of simultaneous users. Behave : Uses tests written in a natural language style, backed up by Python code. Locust are a group of certain species of short-horned grasshoppers in the family Arcididae that have a swarming phase. The name grizzly was chosen based on the grasshopper Melanoplus punctulatus , also known as grizzly spur-throat grasshopper. This species prefers living in trees over grass, which is a hint to Biometria 1 , where grizzly originally was created. 1 Biometria is a member owned and central actor within the swedish forestry that performs unbiased measurement of lumber flowing between forest and industry so that all of Swedens forest owners can feel confident selling their lumber. Documentation More detailed documentation can be found here and the easiest way to get started is to check out the example . Description behave is abused used for being able to define locust load test scenarios using gherkin . A feature can contain more than one scenario and all scenarios will run in parallell. Feature: Rest API endpoint testing Background: Common properties for all scenarios Given \" 2 \" users And spawn rate is \" 2 \" user per second And stop on first failure Scenario: Authorize Given a user of type \" RestApi \" sending requests to \" https://api.example.com \" And repeat for \" 2 \" iterations And wait time inbetween requests is random between \" 0.1 \" and \" 0.3 \" seconds And value for variable \" AtomicDate.called \" is \" now | format='%Y-%m-%dT%H:%M:%S.00Z' timezone=UTC \" And value for variable \" callback_endpoint \" is \" none \" Then post request with name \" authorize \" from endpoint \" /api/v1/authorize?called={{ AtomicDate.called }} \" \"\"\" { \"username\": \"test\", \"password\": \"password123\", \"callback\": \"/api/v1/user/test\" } \"\"\" Then save response payload \" $.callback \" in variable \" callback_endpoint \" Then get request with name \" user info \" from endpoint \" {{ callback_endpoint }} \" When response payload \" $.user.name \" is not \" Test User \" stop user This makes it possible to implement load test scenarios without knowing python or how to use locust . Features A number of features that we thought locust was missing out-of-the-box has been implemented in grizzly . Test data Support for synchronous handling of test data (variables). This is extra important when running locust distributed and there is a need for each worker and user to have unique test data, that cannot be re-used. The solution is heavily inspired by Karol Brejnas locust experiments - feeding the locust . A producer is running on the master (or local) node and keeps track of what has been sent to the consumer running on a worker (or local) node. The two communicates over a seperate ZeroMQ session. When the consumer wants new test data, it sends a message to the server that it is available and for which scenario it is going to run. The producer then responds with unique test data that can be used. Statistics Listeners for both InfluxDB and Azure Application Insights are included. The later is more or less appinsights_listener.py , from the good guys at Svenska Spel , but with typing. They are useful when history of test runs is needed, or when wanting to correlate load tests with other events in the targeted environment. Load test users locust comes with a simple user for loading an HTTP(S) endpoint and due to the nature of how the integration between behave and locust works, it is not possible to use locust provided users, even for HTTP(S) targets. RestApiUser : send requests to REST API endpoinds, supports authentication with username+password or client secret ServiceBusUser : send to Azure Service Bus queues and topics 2 MessageQueueUser : send and receive from IBM MQ queues SftpUser : send and receive files from an SFTP-server BlobStorageUser : send files to Azure Blob Storage 2 2 A pull request for functionality in the other direction is appreciated! Request log All failed requests are logged to a file which includes both header and body, both for request and response. Installation pip3 install grizzly-loadtester pip3 install grizzly-loadtester-cli Do not forget to try the example which also serves as a boilerplate scenario project. Development The easiest way to start contributing to this project is to have Visual Studio Code (with \"Remote - Containers\" extension) and docker installed. The project comes with a devcontainer , which encapsulates everything needed for a development environment. It is also possible to use a python virtual environment where requirements.txt and requirements-dev.txt is installed, and also preferbly the IBM MQ client dependencies and requirements-extras.txt .","title":"Home"},{"location":"#grizzly-zli","text":"Grizzly is a framework to be able to easily define load scenarios, and is mainly built on-top of two other frameworks: Locust : Define user behaviour with Python code, and swarm your system with millions of simultaneous users. Behave : Uses tests written in a natural language style, backed up by Python code. Locust are a group of certain species of short-horned grasshoppers in the family Arcididae that have a swarming phase. The name grizzly was chosen based on the grasshopper Melanoplus punctulatus , also known as grizzly spur-throat grasshopper. This species prefers living in trees over grass, which is a hint to Biometria 1 , where grizzly originally was created. 1 Biometria is a member owned and central actor within the swedish forestry that performs unbiased measurement of lumber flowing between forest and industry so that all of Swedens forest owners can feel confident selling their lumber.","title":"Grizzly - /\u02c8\u0261\u0279\u026azli/"},{"location":"#documentation","text":"More detailed documentation can be found here and the easiest way to get started is to check out the example .","title":"Documentation"},{"location":"#description","text":"behave is abused used for being able to define locust load test scenarios using gherkin . A feature can contain more than one scenario and all scenarios will run in parallell. Feature: Rest API endpoint testing Background: Common properties for all scenarios Given \" 2 \" users And spawn rate is \" 2 \" user per second And stop on first failure Scenario: Authorize Given a user of type \" RestApi \" sending requests to \" https://api.example.com \" And repeat for \" 2 \" iterations And wait time inbetween requests is random between \" 0.1 \" and \" 0.3 \" seconds And value for variable \" AtomicDate.called \" is \" now | format='%Y-%m-%dT%H:%M:%S.00Z' timezone=UTC \" And value for variable \" callback_endpoint \" is \" none \" Then post request with name \" authorize \" from endpoint \" /api/v1/authorize?called={{ AtomicDate.called }} \" \"\"\" { \"username\": \"test\", \"password\": \"password123\", \"callback\": \"/api/v1/user/test\" } \"\"\" Then save response payload \" $.callback \" in variable \" callback_endpoint \" Then get request with name \" user info \" from endpoint \" {{ callback_endpoint }} \" When response payload \" $.user.name \" is not \" Test User \" stop user This makes it possible to implement load test scenarios without knowing python or how to use locust .","title":"Description"},{"location":"#features","text":"A number of features that we thought locust was missing out-of-the-box has been implemented in grizzly .","title":"Features"},{"location":"#test-data","text":"Support for synchronous handling of test data (variables). This is extra important when running locust distributed and there is a need for each worker and user to have unique test data, that cannot be re-used. The solution is heavily inspired by Karol Brejnas locust experiments - feeding the locust . A producer is running on the master (or local) node and keeps track of what has been sent to the consumer running on a worker (or local) node. The two communicates over a seperate ZeroMQ session. When the consumer wants new test data, it sends a message to the server that it is available and for which scenario it is going to run. The producer then responds with unique test data that can be used.","title":"Test data"},{"location":"#statistics","text":"Listeners for both InfluxDB and Azure Application Insights are included. The later is more or less appinsights_listener.py , from the good guys at Svenska Spel , but with typing. They are useful when history of test runs is needed, or when wanting to correlate load tests with other events in the targeted environment.","title":"Statistics"},{"location":"#load-test-users","text":"locust comes with a simple user for loading an HTTP(S) endpoint and due to the nature of how the integration between behave and locust works, it is not possible to use locust provided users, even for HTTP(S) targets. RestApiUser : send requests to REST API endpoinds, supports authentication with username+password or client secret ServiceBusUser : send to Azure Service Bus queues and topics 2 MessageQueueUser : send and receive from IBM MQ queues SftpUser : send and receive files from an SFTP-server BlobStorageUser : send files to Azure Blob Storage 2 2 A pull request for functionality in the other direction is appreciated!","title":"Load test users"},{"location":"#request-log","text":"All failed requests are logged to a file which includes both header and body, both for request and response.","title":"Request log"},{"location":"#installation","text":"pip3 install grizzly-loadtester pip3 install grizzly-loadtester-cli Do not forget to try the example which also serves as a boilerplate scenario project.","title":"Installation"},{"location":"#development","text":"The easiest way to start contributing to this project is to have Visual Studio Code (with \"Remote - Containers\" extension) and docker installed. The project comes with a devcontainer , which encapsulates everything needed for a development environment. It is also possible to use a python virtual environment where requirements.txt and requirements-dev.txt is installed, and also preferbly the IBM MQ client dependencies and requirements-extras.txt .","title":"Development"},{"location":"changelog/","text":"Changelog v1.0.1 dae7be58 : Corrected string comparison operator 4b8a8470 : Adjusted test for messagequeue bd9bb977 : Fix for being able to log MQ request payload cc5dfff6 : updated mkdocs to 1.2.3 due to CVE-2021-40978 604f5704 : fixed url","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#v101","text":"dae7be58 : Corrected string comparison operator 4b8a8470 : Adjusted test for messagequeue bd9bb977 : Fix for being able to log MQ request payload cc5dfff6 : updated mkdocs to 1.2.3 due to CVE-2021-40978 604f5704 : fixed url","title":"v1.0.1"},{"location":"example/","text":"Example The directory example/ is an working project that sends requests to public REST API endpoints, please do not abuse these . Structure The project must have the follwoing structure: . \u2514\u2500\u2500 features \u251c\u2500\u2500 environment.py \u251c\u2500\u2500 test.feature \u251c\u2500\u2500 requests \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 steps \u2514\u2500\u2500 steps.py In this example there are two requirements*.txt files. The reason is that requirements.txt will be copied and installed in the container image if grizzly-cli is used. The container image should not contain grizzly-cli , which is included in requirements-run.txt , and should be installed where scenarios are started from. Environment features/environment.py should contain: from grizzly.environment import * This file can contain overloading of behave hooks to trigger events that should happen during different stages of running a feature file. from grizzly.environment import before_feature as grizzly_before_feature , after_feature as grizzly_after_feature , before_scenario , after_scenario , before_step def before_feature ( context : Context , * args : Tuple [ Any , ... ], ** kwargs : Dict [ str , Any ]) -> None : # custom code that should run before feature file is started, e.g. notify something that a test # is started grizzly_before_feature ( context , * args , ** kwargs ) def after_feature ( context : Context , feature : Feature , * args : Tuple [ Any , ... ], ** kwargs : Dict [ str , Any ]) -> None : grizzly_after_feature ( context , feature , * args , ** kwargs ) # custom code that should run before feature file is started, e.g. notify something that a test # is finished Steps features/steps/steps.py should contain: from grizzly.steps import * This is where custom step implementation can be added, then should look something like: from behave.runner import Context from behave import then # pylint: disable=no-name-in-module from grizzly.steps import * from grizzly.context import GrizzlyContext @then ( u 'this custom step should be executed' ) def step_custom_the_custom_step ( context : Context ) -> None : grizzly = cast ( GrizzlyContext , context . grizzly ) # custom step implementation Request templates features/requests can contain jinja2 templates used in requests. E.g., if the feature file contains the following step: Then send request \" payload.j2.json \" Then features/requests/payload.j2.json needs to exist. Get First do a sparse checkout of the example/ directory in the repository. If you have git older than 2.25.0 , follow these instructions on stackoverflow.com . mkdir grizzly-example cd grizzly-example git init git remote add -f origin https://github.com/Biometria-se/grizzly.git git sparse-checkout init git sparse-checkout set example/ git pull origin main rm -rf .git/ cd example/ Create an python virtual environment and install dependencies: python3 -m venv .env . .env/bin/activate pip3 install -r requirements.txt pip3 install grizzly-loadtester-cli If you do not already have an working \"IBM MQ\" client setup and run grizzly-cli in local mode you will not be able to use MessageQueueUser . See grizzly-cli/static/Containerfile on how to get these. When that is done you need to install the extra dependencies: pip3 install grizzly-loadtester-cli [ mq ] Run grizzly has some runtime features which is easiliest handled by using the grizzly-cli . It provides a simple command line interface wrapping the behave command, for providing initial variable values, configuration etc. If docker and docker-compose are installed, grizzly-cli will by default start the load test in distributed mode (override with --local ). To run the example, in local mode: grizzly-cli --local -c environments/example.yaml features/example.feature And in distributed mode: grizzly-cli -c environments/example.yaml features/example.feature","title":"Example"},{"location":"example/#example","text":"The directory example/ is an working project that sends requests to public REST API endpoints, please do not abuse these .","title":"Example"},{"location":"example/#structure","text":"The project must have the follwoing structure: . \u2514\u2500\u2500 features \u251c\u2500\u2500 environment.py \u251c\u2500\u2500 test.feature \u251c\u2500\u2500 requests \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 steps \u2514\u2500\u2500 steps.py In this example there are two requirements*.txt files. The reason is that requirements.txt will be copied and installed in the container image if grizzly-cli is used. The container image should not contain grizzly-cli , which is included in requirements-run.txt , and should be installed where scenarios are started from.","title":"Structure"},{"location":"example/#environment","text":"features/environment.py should contain: from grizzly.environment import * This file can contain overloading of behave hooks to trigger events that should happen during different stages of running a feature file. from grizzly.environment import before_feature as grizzly_before_feature , after_feature as grizzly_after_feature , before_scenario , after_scenario , before_step def before_feature ( context : Context , * args : Tuple [ Any , ... ], ** kwargs : Dict [ str , Any ]) -> None : # custom code that should run before feature file is started, e.g. notify something that a test # is started grizzly_before_feature ( context , * args , ** kwargs ) def after_feature ( context : Context , feature : Feature , * args : Tuple [ Any , ... ], ** kwargs : Dict [ str , Any ]) -> None : grizzly_after_feature ( context , feature , * args , ** kwargs ) # custom code that should run before feature file is started, e.g. notify something that a test # is finished","title":"Environment"},{"location":"example/#steps","text":"features/steps/steps.py should contain: from grizzly.steps import * This is where custom step implementation can be added, then should look something like: from behave.runner import Context from behave import then # pylint: disable=no-name-in-module from grizzly.steps import * from grizzly.context import GrizzlyContext @then ( u 'this custom step should be executed' ) def step_custom_the_custom_step ( context : Context ) -> None : grizzly = cast ( GrizzlyContext , context . grizzly ) # custom step implementation","title":"Steps"},{"location":"example/#request-templates","text":"features/requests can contain jinja2 templates used in requests. E.g., if the feature file contains the following step: Then send request \" payload.j2.json \" Then features/requests/payload.j2.json needs to exist.","title":"Request templates"},{"location":"example/#get","text":"First do a sparse checkout of the example/ directory in the repository. If you have git older than 2.25.0 , follow these instructions on stackoverflow.com . mkdir grizzly-example cd grizzly-example git init git remote add -f origin https://github.com/Biometria-se/grizzly.git git sparse-checkout init git sparse-checkout set example/ git pull origin main rm -rf .git/ cd example/ Create an python virtual environment and install dependencies: python3 -m venv .env . .env/bin/activate pip3 install -r requirements.txt pip3 install grizzly-loadtester-cli If you do not already have an working \"IBM MQ\" client setup and run grizzly-cli in local mode you will not be able to use MessageQueueUser . See grizzly-cli/static/Containerfile on how to get these. When that is done you need to install the extra dependencies: pip3 install grizzly-loadtester-cli [ mq ]","title":"Get"},{"location":"example/#run","text":"grizzly has some runtime features which is easiliest handled by using the grizzly-cli . It provides a simple command line interface wrapping the behave command, for providing initial variable values, configuration etc. If docker and docker-compose are installed, grizzly-cli will by default start the load test in distributed mode (override with --local ). To run the example, in local mode: grizzly-cli --local -c environments/example.yaml features/example.feature And in distributed mode: grizzly-cli -c environments/example.yaml features/example.feature","title":"Run"},{"location":"licenses/","text":"Licenses The MIT License (MIT) Copyright \u00a9 2021 Biometria Ekonomiska F\u00f6rening Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Third party licenses Python dependencies Name Version License protobuf 3.19.0 3-Clause BSD License PyNaCl 1.4.0 Apache License 2.0 backports.zoneinfo 0.2.1 Apache Software License bcrypt 3.2.0 Apache Software License bleach 4.1.0 Apache Software License coverage 6.0.2 Apache Software License dataclasses 0.6 Apache Software License ghp-import 2.0.2 Apache Software License google-api-core 2.1.1 Apache Software License google-auth 2.3.0 Apache Software License googleapis-common-protos 1.53.0 Apache Software License importlib-metadata 4.8.1 Apache Software License jsonpath-ng 1.5.3 Apache Software License msgpack 1.0.2 Apache Software License opencensus 0.8.0 Apache Software License opencensus-context 0.1.2 Apache Software License opencensus-ext-azure 1.0.8 Apache Software License readme-renderer 30.0 Apache Software License requests 2.26.0 Apache Software License requests-toolbelt 0.9.1 Apache Software License rfc3986 1.5.0 Apache Software License rsa 4.7.2 Apache Software License twine 3.4.2 Apache Software License types-PyYAML 5.4.10 Apache Software License types-cryptography 3.3.7 Apache Software License types-enum34 1.1.1 Apache Software License types-ipaddress 1.0.1 Apache Software License types-paramiko 0.1.9 Apache Software License types-python-dateutil 2.8.0 Apache Software License types-pytz 2021.1.2 Apache Software License types-requests 2.25.6 Apache Software License types-tzlocal 0.1.1 Apache Software License watchdog 2.1.6 Apache Software License cryptography 35.0.0 Apache Software License; BSD License packaging 21.0 Apache Software License; BSD License python-dateutil 2.8.2 Apache Software License; BSD License ply 3.11 BSD Flask 2.0.2 BSD License Flask-BasicAuth 0.2.0 BSD License Jinja2 3.0.1 BSD License Markdown 3.3.4 BSD License MarkupSafe 2.0.1 BSD License Pygments 2.10.0 BSD License SecretStorage 3.3.1 BSD License Werkzeug 2.0.2 BSD License aenum 3.1.0 BSD License astunparse 1.6.3 BSD License behave 1.2.6 BSD License click 8.0.3 BSD License colorama 0.4.4 BSD License decorator 5.1.0 BSD License idna 3.3 BSD License isodate 0.6.0 BSD License itsdangerous 2.0.1 BSD License lazy-object-proxy 1.6.0 BSD License lxml 4.6.3 BSD License mkdocs 1.2.3 BSD License oauthlib 3.1.1 BSD License parse 1.19.0 BSD License parse-type 0.5.2 BSD License psutil 5.8.0 BSD License pyasn1 0.4.8 BSD License pyasn1-modules 0.2.8 BSD License pycparser 2.20 BSD License requests-oauthlib 1.3.0 BSD License setproctitle 1.2.2 BSD License webencodings 0.5.1 BSD License wrapt 1.13.2 BSD License docutils 0.17.1 BSD License; GNU General Public License (GPL); Public Domain; Python Software Foundation License pyzmq 22.2.1 BSD License; GNU Library or Lesser General Public License (LGPL) pytest-timeout 1.4.2 DFSG approved; MIT License pylint 2.11.1 GNU General Public License v2 (GPLv2) astroid 2.8.3 GNU Lesser General Public License v2 (LGPLv2) chardet 4.0.0 GNU Library or Lesser General Public License (LGPL) paramiko 2.7.2 GNU Library or Lesser General Public License (LGPL) geventhttpclient 1.5.3 LICENSE-MIT databind.core 1.2.4 MIT databind.json 1.2.4 MIT docspec 1.2.0 MIT docspec-python 1.2.0 MIT nr.fs 1.6.3 MIT nr.optional 0.2.0 MIT nr.parsing.date 1.0.3 MIT nr.preconditions 0.0.4 MIT nr.pylang.utils 0.1.3 MIT nr.stream 0.2.3 MIT nr.utils.re 0.3.1 MIT Brotli 1.0.9 MIT License ConfigArgParse 1.5.3 MIT License DataProperty 0.54.2 MIT License Deprecated 1.2.13 MIT License Flask-Cors 3.0.10 MIT License PyYAML 5.4.1 MIT License attrs 21.2.0 MIT License azure-common 1.1.27 MIT License azure-core 1.19.0 MIT License azure-servicebus 7.3.3 MIT License azure-storage-blob 12.8.1 MIT License cachetools 4.2.4 MIT License cffi 1.15.0 MIT License charset-normalizer 2.0.7 MIT License gevent 21.8.0 MIT License greenlet 1.1.2 MIT License influxdb 5.3.1 MIT License iniconfig 1.1.1 MIT License isort 5.9.3 MIT License jeepney 0.7.1 MIT License locust 2.2.1 MIT License mbstrdecoder 1.1.0 MIT License mccabe 0.6.1 MIT License mergedeep 1.3.4 MIT License mkdocs-material 7.3.4 MIT License mkdocs-material-extensions 1.0.3 MIT License msrest 0.6.21 MIT License mypy 0.910 MIT License mypy-extensions 0.4.3 MIT License pathvalidate 2.5.0 MIT License pkginfo 1.7.1 MIT License platformdirs 2.4.0 MIT License pluggy 1.0.0 MIT License py 1.10.0 MIT License pydoc-markdown 4.3.2 MIT License pymdown-extensions 9.0 MIT License pyparsing 3.0.1 MIT License pytablewriter 0.63.0 MIT License pytest 6.2.5 MIT License pytest-cov 2.12.1 MIT License pytest-mock 3.6.1 MIT License pytz 2021.1 MIT License pyyaml-env-tag 0.1 MIT License roundrobin 0.0.2 MIT License six 1.16.0 MIT License tabledata 1.3.0 MIT License tcolorpy 0.1.1 MIT License toml 0.10.2 MIT License typepy 1.3.0 MIT License tzlocal 3.0 MIT License uamqp 1.4.3 MIT License urllib3 1.26.7 MIT License zipp 3.6.0 MIT License tqdm 4.62.3 MIT License; Mozilla Public License 2.0 (MPL 2.0) keyring 23.2.1 MIT License; Python Software Foundation License certifi 2021.10.8 Mozilla Public License 2.0 (MPL 2.0) typing-extensions 3.10.0.2 Python Software Foundation License zope.event 4.5.0 Zope Public License zope.interface 5.4.0 Zope Public License Native dependencies Container images (both grizzly runtime and Microsoft Visual Code devcontainer) contains dependencies from IBM MQ Redistributable Components . The redistributable license terms may be found in the relevant IBM MQ Program license agreement, which may be found at the IBM Software License Agreements website, or in licenses/ directory in the archive .","title":"Licenses"},{"location":"licenses/#licenses","text":"","title":"Licenses"},{"location":"licenses/#the-mit-license-mit","text":"Copyright \u00a9 2021 Biometria Ekonomiska F\u00f6rening Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"The MIT License (MIT)"},{"location":"licenses/#third-party-licenses","text":"","title":"Third party licenses"},{"location":"licenses/#python-dependencies","text":"Name Version License protobuf 3.19.0 3-Clause BSD License PyNaCl 1.4.0 Apache License 2.0 backports.zoneinfo 0.2.1 Apache Software License bcrypt 3.2.0 Apache Software License bleach 4.1.0 Apache Software License coverage 6.0.2 Apache Software License dataclasses 0.6 Apache Software License ghp-import 2.0.2 Apache Software License google-api-core 2.1.1 Apache Software License google-auth 2.3.0 Apache Software License googleapis-common-protos 1.53.0 Apache Software License importlib-metadata 4.8.1 Apache Software License jsonpath-ng 1.5.3 Apache Software License msgpack 1.0.2 Apache Software License opencensus 0.8.0 Apache Software License opencensus-context 0.1.2 Apache Software License opencensus-ext-azure 1.0.8 Apache Software License readme-renderer 30.0 Apache Software License requests 2.26.0 Apache Software License requests-toolbelt 0.9.1 Apache Software License rfc3986 1.5.0 Apache Software License rsa 4.7.2 Apache Software License twine 3.4.2 Apache Software License types-PyYAML 5.4.10 Apache Software License types-cryptography 3.3.7 Apache Software License types-enum34 1.1.1 Apache Software License types-ipaddress 1.0.1 Apache Software License types-paramiko 0.1.9 Apache Software License types-python-dateutil 2.8.0 Apache Software License types-pytz 2021.1.2 Apache Software License types-requests 2.25.6 Apache Software License types-tzlocal 0.1.1 Apache Software License watchdog 2.1.6 Apache Software License cryptography 35.0.0 Apache Software License; BSD License packaging 21.0 Apache Software License; BSD License python-dateutil 2.8.2 Apache Software License; BSD License ply 3.11 BSD Flask 2.0.2 BSD License Flask-BasicAuth 0.2.0 BSD License Jinja2 3.0.1 BSD License Markdown 3.3.4 BSD License MarkupSafe 2.0.1 BSD License Pygments 2.10.0 BSD License SecretStorage 3.3.1 BSD License Werkzeug 2.0.2 BSD License aenum 3.1.0 BSD License astunparse 1.6.3 BSD License behave 1.2.6 BSD License click 8.0.3 BSD License colorama 0.4.4 BSD License decorator 5.1.0 BSD License idna 3.3 BSD License isodate 0.6.0 BSD License itsdangerous 2.0.1 BSD License lazy-object-proxy 1.6.0 BSD License lxml 4.6.3 BSD License mkdocs 1.2.3 BSD License oauthlib 3.1.1 BSD License parse 1.19.0 BSD License parse-type 0.5.2 BSD License psutil 5.8.0 BSD License pyasn1 0.4.8 BSD License pyasn1-modules 0.2.8 BSD License pycparser 2.20 BSD License requests-oauthlib 1.3.0 BSD License setproctitle 1.2.2 BSD License webencodings 0.5.1 BSD License wrapt 1.13.2 BSD License docutils 0.17.1 BSD License; GNU General Public License (GPL); Public Domain; Python Software Foundation License pyzmq 22.2.1 BSD License; GNU Library or Lesser General Public License (LGPL) pytest-timeout 1.4.2 DFSG approved; MIT License pylint 2.11.1 GNU General Public License v2 (GPLv2) astroid 2.8.3 GNU Lesser General Public License v2 (LGPLv2) chardet 4.0.0 GNU Library or Lesser General Public License (LGPL) paramiko 2.7.2 GNU Library or Lesser General Public License (LGPL) geventhttpclient 1.5.3 LICENSE-MIT databind.core 1.2.4 MIT databind.json 1.2.4 MIT docspec 1.2.0 MIT docspec-python 1.2.0 MIT nr.fs 1.6.3 MIT nr.optional 0.2.0 MIT nr.parsing.date 1.0.3 MIT nr.preconditions 0.0.4 MIT nr.pylang.utils 0.1.3 MIT nr.stream 0.2.3 MIT nr.utils.re 0.3.1 MIT Brotli 1.0.9 MIT License ConfigArgParse 1.5.3 MIT License DataProperty 0.54.2 MIT License Deprecated 1.2.13 MIT License Flask-Cors 3.0.10 MIT License PyYAML 5.4.1 MIT License attrs 21.2.0 MIT License azure-common 1.1.27 MIT License azure-core 1.19.0 MIT License azure-servicebus 7.3.3 MIT License azure-storage-blob 12.8.1 MIT License cachetools 4.2.4 MIT License cffi 1.15.0 MIT License charset-normalizer 2.0.7 MIT License gevent 21.8.0 MIT License greenlet 1.1.2 MIT License influxdb 5.3.1 MIT License iniconfig 1.1.1 MIT License isort 5.9.3 MIT License jeepney 0.7.1 MIT License locust 2.2.1 MIT License mbstrdecoder 1.1.0 MIT License mccabe 0.6.1 MIT License mergedeep 1.3.4 MIT License mkdocs-material 7.3.4 MIT License mkdocs-material-extensions 1.0.3 MIT License msrest 0.6.21 MIT License mypy 0.910 MIT License mypy-extensions 0.4.3 MIT License pathvalidate 2.5.0 MIT License pkginfo 1.7.1 MIT License platformdirs 2.4.0 MIT License pluggy 1.0.0 MIT License py 1.10.0 MIT License pydoc-markdown 4.3.2 MIT License pymdown-extensions 9.0 MIT License pyparsing 3.0.1 MIT License pytablewriter 0.63.0 MIT License pytest 6.2.5 MIT License pytest-cov 2.12.1 MIT License pytest-mock 3.6.1 MIT License pytz 2021.1 MIT License pyyaml-env-tag 0.1 MIT License roundrobin 0.0.2 MIT License six 1.16.0 MIT License tabledata 1.3.0 MIT License tcolorpy 0.1.1 MIT License toml 0.10.2 MIT License typepy 1.3.0 MIT License tzlocal 3.0 MIT License uamqp 1.4.3 MIT License urllib3 1.26.7 MIT License zipp 3.6.0 MIT License tqdm 4.62.3 MIT License; Mozilla Public License 2.0 (MPL 2.0) keyring 23.2.1 MIT License; Python Software Foundation License certifi 2021.10.8 Mozilla Public License 2.0 (MPL 2.0) typing-extensions 3.10.0.2 Python Software Foundation License zope.event 4.5.0 Zope Public License zope.interface 5.4.0 Zope Public License","title":"Python dependencies"},{"location":"licenses/#native-dependencies","text":"Container images (both grizzly runtime and Microsoft Visual Code devcontainer) contains dependencies from IBM MQ Redistributable Components . The redistributable license terms may be found in the relevant IBM MQ Program license agreement, which may be found at the IBM Software License Agreements website, or in licenses/ directory in the archive .","title":"Native dependencies"},{"location":"usage/cli/","text":"Command Line Interface grizzly has a command line interface that is installed separately. The command line interface is called with grizzly-cli , and makes it easier to start a test with all features of grizzly wrapped up nicely. Installation pip install grizzly-loadtester-cli Usage grizzly-cli [-h] [--local | --workers WORKERS] [--force-build | --build] [--verbose] [-T TESTDATA_VARIABLE=VALUE, [-T TESTDATA_VARIABLE=VALUE, [...]]] [-c CONFIG_FILE] [file] --local If docker and docker-compose are in $PATH , but locust should not run in distributed mode. This parameter can not be used in combination with --workers , --force-build or --build . --workers How many instances of the workers container that should be started. This parameter can not be used in combination with --local . --force-build If the container image for master and worker nodes should be re-built without cache. This takes a little time. This parameter can not be used in combination with --local or --build . --build If the container image for master and worker nodes should be re-built with cache. This is the faster option, but could result in an image that isn't correctly updated. This parameter can not be used in combination with --local or --force-build . --verbose Changes the log level to DEBUG , regardless of what it says in the feature file. Gives more verbose logging that can be useful when troubleshooting a problem with a load test scenario. -T TESTDATA_VARIABLE=VALUE If the feature file contains the step: And ask for value of ... grizzly-cli will give you an prompt to enter the (initial) value for that variable, and you will have to confirm that the provided value is correct. With this parameter you can provide the initial value when starting the test, in which case there will not be an prompt. -c CONFIG_FILE, --config-file CONFIG_FILE A path to an environment configuration file .","title":"Command Line Interface"},{"location":"usage/cli/#command-line-interface","text":"grizzly has a command line interface that is installed separately. The command line interface is called with grizzly-cli , and makes it easier to start a test with all features of grizzly wrapped up nicely.","title":"Command Line Interface"},{"location":"usage/cli/#installation","text":"pip install grizzly-loadtester-cli","title":"Installation"},{"location":"usage/cli/#usage","text":"grizzly-cli [-h] [--local | --workers WORKERS] [--force-build | --build] [--verbose] [-T TESTDATA_VARIABLE=VALUE, [-T TESTDATA_VARIABLE=VALUE, [...]]] [-c CONFIG_FILE] [file]","title":"Usage"},{"location":"usage/cli/#-local","text":"If docker and docker-compose are in $PATH , but locust should not run in distributed mode. This parameter can not be used in combination with --workers , --force-build or --build .","title":"--local"},{"location":"usage/cli/#-workers","text":"How many instances of the workers container that should be started. This parameter can not be used in combination with --local .","title":"--workers"},{"location":"usage/cli/#-force-build","text":"If the container image for master and worker nodes should be re-built without cache. This takes a little time. This parameter can not be used in combination with --local or --build .","title":"--force-build"},{"location":"usage/cli/#-build","text":"If the container image for master and worker nodes should be re-built with cache. This is the faster option, but could result in an image that isn't correctly updated. This parameter can not be used in combination with --local or --force-build .","title":"--build"},{"location":"usage/cli/#-verbose","text":"Changes the log level to DEBUG , regardless of what it says in the feature file. Gives more verbose logging that can be useful when troubleshooting a problem with a load test scenario.","title":"--verbose"},{"location":"usage/cli/#-t-testdata_variablevalue","text":"If the feature file contains the step: And ask for value of ... grizzly-cli will give you an prompt to enter the (initial) value for that variable, and you will have to confirm that the provided value is correct. With this parameter you can provide the initial value when starting the test, in which case there will not be an prompt.","title":"-T TESTDATA_VARIABLE=VALUE"},{"location":"usage/cli/#-c-config_file-config-file-config_file","text":"A path to an environment configuration file .","title":"-c CONFIG_FILE, --config-file CONFIG_FILE"},{"location":"usage/load-users/blob-storage/","text":"grizzly.users.blobstorage Communicates with Azure Blob Storage. Format of host is the following: [DefaultEndpointsProtocol=]https;EndpointSuffix=<hostname>;AccountName=<account name>;AccountKey=<account key> endpoint in the request is the name of the blob storage container. Name of the targeted file in the container is either name or based on the file name of source . Example of how to use it in a scenario: Given a user of type \" BlobStorage \" load testing \" DefaultEndpointsProtocol=https;EndpointSuffix=core.windows.net;AccountName=examplestorage;AccountKey=xxxyyyyzzz== \" Then send request \" test/blob.file \" to endpoint \" azure-blobstorage-container-name \" Supports the following request methods: send put","title":"Blob Storage"},{"location":"usage/load-users/blob-storage/#grizzlyusersblobstorage","text":"Communicates with Azure Blob Storage. Format of host is the following: [DefaultEndpointsProtocol=]https;EndpointSuffix=<hostname>;AccountName=<account name>;AccountKey=<account key> endpoint in the request is the name of the blob storage container. Name of the targeted file in the container is either name or based on the file name of source . Example of how to use it in a scenario: Given a user of type \" BlobStorage \" load testing \" DefaultEndpointsProtocol=https;EndpointSuffix=core.windows.net;AccountName=examplestorage;AccountKey=xxxyyyyzzz== \" Then send request \" test/blob.file \" to endpoint \" azure-blobstorage-container-name \" Supports the following request methods: send put","title":"grizzly.users.blobstorage"},{"location":"usage/load-users/message-queue/","text":"grizzly.users.messagequeue Communicates with IBM MQ. User is based on pymqi for communicating with IBM MQ. However pymqi uses native libraries which gevent (used by locust ) cannot patch, which causes any calls in pymqi to block the rest of locust . To get around this, the user implementation communicates with a stand-alone process via zmq, which then in turn communicates with IBM MQ. The message queue daemon process is started automagically when a scenario contains the MessageQueueUser and pymqi dependencies are installed. Format of host is the following: mq://<hostname>:<port>/?QueueManager=<queue manager name>&Channel=<channel name> endpoint in the request is the name of an MQ queue. Example of how to use it in a scenario: Given a user of type \" MessageQueue \" load testing \" mq://mq.example.com/?QueueManager=QM01&Channel=SRVCONN01 \" Then put request \" test/queue-message.j2.json \" with name \" queue-message \" to endpoint \" INCOMING.MESSAGES \" Supports the following request methods: send put get receive GET / RECEIVE Default behavior is to fail directly if there is no message on the queue. If the request should wait until a message is available, set the time it should wait with message.wait (seconds) context variable. Given a user of type \" MessageQueue \" load testing \" mq://mq.example.com/?QueueManager=QM01&Channel=SRVCONN01 \" And set context variable \" message.wait \" to \" 5 \" Then get request with name \" get-queue-message \" from endpoint \" INCOMING.MESSAGES \" In this example, the request will not fail if there is a message on queue within 5 seconds. Authentication Username and password Given a user of type \" MessageQueue \" load testing \" mq://mqm:admin@mq.example.com/?QueueManager=QM01&Channel=SRVCONN01 \" And set context variable \" auth.username \" to \" <username> \" And set context variable \" auth.password \" to \" <password> \" With TLS A key repository (3 files; .kdb , .rdb and .sth ) for the user is needed, and is specified with auth.key_file excluding the file extension. Given a user of type \" MessageQueue \" load testing \" mq://mqm:admin@mq.example.com/?QueueManager=QM01&Channel=SRVCONN01 \" And set context variable \" auth.username \" to \" <username> \" And set context variable \" auth.password \" to \" <password> \" And set context variable \" auth.key_file \" to \" <path to key file, excl. file extension> \" Default SSL cipher is ECDHE_RSA_AES_256_GCM_SHA384 , change it by setting auth.ssl_cipher context variable. Default certificate label is set to auth.username , change it by setting auth.cert_label context variable.","title":"Message Queue"},{"location":"usage/load-users/message-queue/#grizzlyusersmessagequeue","text":"Communicates with IBM MQ. User is based on pymqi for communicating with IBM MQ. However pymqi uses native libraries which gevent (used by locust ) cannot patch, which causes any calls in pymqi to block the rest of locust . To get around this, the user implementation communicates with a stand-alone process via zmq, which then in turn communicates with IBM MQ. The message queue daemon process is started automagically when a scenario contains the MessageQueueUser and pymqi dependencies are installed. Format of host is the following: mq://<hostname>:<port>/?QueueManager=<queue manager name>&Channel=<channel name> endpoint in the request is the name of an MQ queue. Example of how to use it in a scenario: Given a user of type \" MessageQueue \" load testing \" mq://mq.example.com/?QueueManager=QM01&Channel=SRVCONN01 \" Then put request \" test/queue-message.j2.json \" with name \" queue-message \" to endpoint \" INCOMING.MESSAGES \" Supports the following request methods: send put get receive","title":"grizzly.users.messagequeue"},{"location":"usage/load-users/message-queue/#get-receive","text":"Default behavior is to fail directly if there is no message on the queue. If the request should wait until a message is available, set the time it should wait with message.wait (seconds) context variable. Given a user of type \" MessageQueue \" load testing \" mq://mq.example.com/?QueueManager=QM01&Channel=SRVCONN01 \" And set context variable \" message.wait \" to \" 5 \" Then get request with name \" get-queue-message \" from endpoint \" INCOMING.MESSAGES \" In this example, the request will not fail if there is a message on queue within 5 seconds.","title":"GET / RECEIVE"},{"location":"usage/load-users/message-queue/#authentication","text":"","title":"Authentication"},{"location":"usage/load-users/message-queue/#username-and-password","text":"Given a user of type \" MessageQueue \" load testing \" mq://mqm:admin@mq.example.com/?QueueManager=QM01&Channel=SRVCONN01 \" And set context variable \" auth.username \" to \" <username> \" And set context variable \" auth.password \" to \" <password> \"","title":"Username and password"},{"location":"usage/load-users/message-queue/#with-tls","text":"A key repository (3 files; .kdb , .rdb and .sth ) for the user is needed, and is specified with auth.key_file excluding the file extension. Given a user of type \" MessageQueue \" load testing \" mq://mqm:admin@mq.example.com/?QueueManager=QM01&Channel=SRVCONN01 \" And set context variable \" auth.username \" to \" <username> \" And set context variable \" auth.password \" to \" <password> \" And set context variable \" auth.key_file \" to \" <path to key file, excl. file extension> \" Default SSL cipher is ECDHE_RSA_AES_256_GCM_SHA384 , change it by setting auth.ssl_cipher context variable. Default certificate label is set to auth.username , change it by setting auth.cert_label context variable.","title":"With TLS"},{"location":"usage/load-users/rest-api/","text":"grizzly.users.restapi Communicates with HTTP and HTTPS, with built-in support for Azure authenticated endpoints. Format of host is the following: http[s]://<hostname> Example on how to use it in a scenario: Given a user of type \" RestApi \" load testing \" https://api.example.com \" Then post request \" test/request.j2.json \" to endpoint \" /api/test \" Then get request from endpoint \" /api/test \" To change how often the token should be refreshed, default is 3000 seconds: And set context variable \" auth.refresh_time \" to \" 3500 \" Supports the following request methods: get put post Authentication Client secret Given a user of type \" RestApi \" load testing \" https://api.example.com \" And set context variable \" auth.client.tenant \" \" <tenant name/guid> \" And set context variable \" auth.client.id \" to \" <client id> \" And set context variable \" auth.client.secret \" to \" <client secret> \" And set context variable \" auth.client.resource \" to \" <resource url/guid> \" Username and password auth.user.redirect_uri needs to correspond to the endpoint that the client secret is registrered for. Given a user of type \" RestApi \" load testing \" https://api.example.com \" And set context variable \" auth.client.id \" to \" <client id> \" And set context variable \" auth.user.username \" to \" alice@example.onmicrosoft.com \" And set context variable \" auth.user.password \" to \" HemL1gaArn3! \" And set context variable \" auth.user.redirect_uri \" to \" /app-registrered-redirect-uri \"","title":"Rest API"},{"location":"usage/load-users/rest-api/#grizzlyusersrestapi","text":"Communicates with HTTP and HTTPS, with built-in support for Azure authenticated endpoints. Format of host is the following: http[s]://<hostname> Example on how to use it in a scenario: Given a user of type \" RestApi \" load testing \" https://api.example.com \" Then post request \" test/request.j2.json \" to endpoint \" /api/test \" Then get request from endpoint \" /api/test \" To change how often the token should be refreshed, default is 3000 seconds: And set context variable \" auth.refresh_time \" to \" 3500 \" Supports the following request methods: get put post","title":"grizzly.users.restapi"},{"location":"usage/load-users/rest-api/#authentication","text":"","title":"Authentication"},{"location":"usage/load-users/rest-api/#client-secret","text":"Given a user of type \" RestApi \" load testing \" https://api.example.com \" And set context variable \" auth.client.tenant \" \" <tenant name/guid> \" And set context variable \" auth.client.id \" to \" <client id> \" And set context variable \" auth.client.secret \" to \" <client secret> \" And set context variable \" auth.client.resource \" to \" <resource url/guid> \"","title":"Client secret"},{"location":"usage/load-users/rest-api/#username-and-password","text":"auth.user.redirect_uri needs to correspond to the endpoint that the client secret is registrered for. Given a user of type \" RestApi \" load testing \" https://api.example.com \" And set context variable \" auth.client.id \" to \" <client id> \" And set context variable \" auth.user.username \" to \" alice@example.onmicrosoft.com \" And set context variable \" auth.user.password \" to \" HemL1gaArn3! \" And set context variable \" auth.user.redirect_uri \" to \" /app-registrered-redirect-uri \"","title":"Username and password"},{"location":"usage/load-users/secure-file-transfer-protocol/","text":"grizzly.users.sftp Communicates with Secure File Transport Protocol. Format of host is the following: sftp://<host>[:<port>] Example of how to use it in a scenario: Given a user of type \" Sftp \" load testing \" sftp://sftp.example.com \" And set context variable \" auth.username \" to \" bob \" And set context variable \" auth.password \" to \" great-scott-42-file-bar \" Then put request \" test/blob.file \" to endpoint \" /pub/blobs \" Then get request from endpoint \" /pub/blobs/blob.file \" Supports the following request methods: put get Both local and remote files will be overwritten if they already exists. Downloaded files will be stored in requests/download .","title":"Secure File Transfer Protocol"},{"location":"usage/load-users/secure-file-transfer-protocol/#grizzlyuserssftp","text":"Communicates with Secure File Transport Protocol. Format of host is the following: sftp://<host>[:<port>] Example of how to use it in a scenario: Given a user of type \" Sftp \" load testing \" sftp://sftp.example.com \" And set context variable \" auth.username \" to \" bob \" And set context variable \" auth.password \" to \" great-scott-42-file-bar \" Then put request \" test/blob.file \" to endpoint \" /pub/blobs \" Then get request from endpoint \" /pub/blobs/blob.file \" Supports the following request methods: put get Both local and remote files will be overwritten if they already exists. Downloaded files will be stored in requests/download .","title":"grizzly.users.sftp"},{"location":"usage/load-users/service-bus/","text":"grizzly.users.servicebus Communicates with Azure Service Bus. Format of host is the following: [Endpoint=]sb://<hostname>/;SharedAccessKeyName=<shared key name>;SharedAccessKey=<shared key> endpoint in the request must have the prefix queue: or topic: followed by the name of the targeted type. Example of how to use it in a scenario: Given a user of type \" ServiceBus \" load testing \" sb://sb.example.com/;SharedAccessKeyName=authorization-key;SharedAccessKeyc2VjcmV0LXN0dWZm \" Then send request \" servicebus.msg \" to endpoint \" queue:shared-queue \" Then send request \" servicebus.msg \" to endpoint \" topic:shared-topic \" Supports the following request methods: send","title":"Service Bus"},{"location":"usage/load-users/service-bus/#grizzlyusersservicebus","text":"Communicates with Azure Service Bus. Format of host is the following: [Endpoint=]sb://<hostname>/;SharedAccessKeyName=<shared key name>;SharedAccessKey=<shared key> endpoint in the request must have the prefix queue: or topic: followed by the name of the targeted type. Example of how to use it in a scenario: Given a user of type \" ServiceBus \" load testing \" sb://sb.example.com/;SharedAccessKeyName=authorization-key;SharedAccessKeyc2VjcmV0LXN0dWZm \" Then send request \" servicebus.msg \" to endpoint \" queue:shared-queue \" Then send request \" servicebus.msg \" to endpoint \" topic:shared-topic \" Supports the following request methods: send","title":"grizzly.users.servicebus"},{"location":"usage/steps/anywhere/","text":"grizzly.steps.setup step_setup_variable_value_ask @given ( u 'ask for value of variable \" {name} \"' ) def step_setup_variable_value_ask ( context : Context , name : str ) -> None This step is used to indicate for grizzly-cli that it should ask for an initial value for the variable. It will then inject the value into the locust runtime environment, and in this step read it and insert it into the locust context which grizzly will use to setup locust. If grizzly-cli is not used, one has to manually set the environment variable, which requires a prefix of TESTDATA_VARIABLE_ and the suffix should match the variable name in question. Use this step for variables that should have different initial values for each run of the feature. And ask for value for variable \" AtomicIntegerIncrementer.messageID \" Arguments : name str - variable name used in templates grizzly.steps.scenario This package contains step implementations that only is allowed in the Scenario section in a feature file. grizzly.steps.scenario.setup This module contains step implementations that setup the load test scenario with parameters that is going to be used in the scenario they are defined in. step_setup_set_context_variable @given ( u 'set context variable \" {variable} \" to \" {value} \"' ) def step_setup_set_context_variable ( context : Context , variable : str , value : str ) -> None Set a variable in the scenario context. Variable name can contain (one or more) dot ( . ) or slash ( / ) to indicate that the variable has a nested structure. E.g. token.url and token/url results in: It is also possible to have spaces in a variable name, they will then be replaced with underscore ( _ ), and name will be converted to lowercase. E.g. Client ID results in client_id { ' t oke n ' : { 'url' : '<value>' } } And set context variable \" token.url \" to \" https://example.com/api/auth \" And set context variable \" token/client_id \" to \" aaaa-bbbb-cccc-dddd \" And set context variable \" token/client secret \" to \" aasdfasdfasdf== \" And set context variable \" token.resource \" to \" 0000-aaaaaaa-1111-1111-1111 \" And set context variable \" log_all_requests \" to \" True \" And set context variable \" validate_certificates \" to \" False \" Arguments : variable str - name, can contain . and / value str - value, data type will be guessed and casted step_setup_iterations @given ( u 'repeat for \" {value} \" {iteration_number:IterationGramaticalNumber}' ) def step_setup_iterations ( context : Context , value : str , iteration_number : str ) -> None Set how many iterations of the requests in the scenario should execute. Default value is 1 . A value of 0 means to run until all test data is consumed, or that the (optional) specified runtime for the scenario is reached. And repeat for \" 10 \" iterations And repeat for \" 1 \" iteration And value for variable \" leveranser \" is \" 100 \" And repeat for \" {{ leveranser * 0.25 }} \" iterations Arguments : iterations int - number of iterations of the scenario step_setup_wait_time @given ( u 'wait time inbetween requests is random between \" {minimum:f} \" and \" {maximum:f} \" seconds' ) def step_setup_wait_time ( context : Context , minimum : float , maximum : float ) -> None Set how long (seconds) locust should wait between tasks. Default value is 1.0 seconds. Set wait_min = wait_max if the wait shouldn't be random in the specified interval. And wait time inbetween requests is random between \" 0.3 \" and \" 0.5 \" seconds Arguments : wait_min float - minimum wait time wait_max float - maximum wait time step_setup_variable_value @given ( u 'value for variable \" {name} \" is \" {value} \"' ) def step_setup_variable_value ( context : Context , name : str , value : str ) -> None Initialize a variable. Use this step to initialize a variable that should have the same [start] value for every run of the scenario. Data type for the value of the variable is based on the type of variable. If the variable is an \" Atomic* \"-variable then the value needs to match the format and type that the variable has implemented. If it is a non \" Atomic* \"-variable grizzly will try to guess the data type. E.g.: * \"10\" becomes int * \"1.0\" becomes float * \"True\" becomes bool * everything else becomes str It is possible to set the value of a variable based on another variable, which can be usable if you have a variable in multiple scenarios which all should have the same initial value. And value for variable \" HelloWorld \" is \" default \" Feature: Background: And ask for value of variable \" messageID \" Scenario: And value for variable \" AtomicIntegerIncrementer.mid1 \" is \" {{ messageID }} \" Arguments : name str - variable name value Any - initial value step_setup_set_variable_alias @given ( u 'set alias \" {alias} \" for variable \" {variable} \"' ) def step_setup_set_variable_alias ( context : Context , alias : str , variable : str ) -> None Create an alias for a variable that points to another structure in the context. This is useful if you have test data that somehow should change the behavior for a user, e.g. username and password. Assumed that the file users.csv contains the columns username and password ; without the alias step it would look like the following structure in the context: With the alias step it will be transformed to this: Variables in payload templates are not allowed to have an alias. And set variable \" AtomicCsvRow.users \" to \" users.csv | repeat=True \" And set alias \" auth.user.username \" for variable \" AtomicCsvRow.users.username \" And set alias \" auth.user.password \" for variable \" AtomicCsvRow.users.password \" { \"variables\" : { \"AtomicCsvRow\" : { \"users\" : { \"username\" : \"username\" , \"password\" : \"password\" } } } } { \"auth\" : { \"user\" : { \"username\" : \"username\" , \"password\" : \"password\" } } } Arguments : alias str - which node in the context that should get the value of variable variable str - an already initialized variable that should be renamed step_setup_log_all_requests @given ( u 'log all requests' ) def step_setup_log_all_requests ( context : Context ) -> None Set if all requests should be logged to a file. By default only failed requests (and responses) will be logged. And log all requests step_setup_enable_stop_on_failure @given ( u 'stop on first failure' ) def step_setup_enable_stop_on_failure ( context : Context ) -> None Stop a scenario at first failed request. Default behavior is to continue the scenario if a request fails. And stop on first failure grizzly.steps.scenario.response This module contains step implementations that handles request responses. step_response_save_matches @then ( u 'save response {target:ResponseTarget} \" {expression} \" that matches \" {match_with} \" in variable \" {variable} \"' ) def step_response_save_matches ( context : Context , target : ResponseTarget , expression : str , match_with : str , variable : str ) -> None Save specified parts of a response, either from meta data (header) or payload (body), in a variable. With this step it is possible to change variable values and as such use values from a response later on in the load test. This step will fail if the specified expression has no match or more than one match. # only token is matched and saved in TOKEN, by using regexp match groups And value of variable \" TOKEN \" is \" none \" Then save response metadata \" $.Authentication \" that matches \" Bearer (.*)$ \" in variabel \" TOKEN \" # the whole value is saved, as long as Authentication starts with \"Bearer\" And value of variable \" HEADER_AUTHENTICATION \" is \" none \" Then save response metadata \" $.Authentication \" that matches \" ^Bearer .*$ \" in variable \" HEADER_AUTHENTICATION \" # only the numerical suffix is saved in the variable And value of variable \" AtomicInteger.measurermentId \" is \" 0 \" Then save response payload \" $.measurement.id \" that matches \" ^cpu([\\\\d]+)$ \" in \" AtomicInteger.measurementId \" # the whole value is saved, as long as the value starts with \"cpu\" And value of variable \" measurementId \" is \" 0 \" Then save response payload \" $.measurement.id \" that matches \" ^cpu[\\\\d]+$ \" in \" measurementId \" # xpath example And set response content type to \" application/xml \" And value of variable \" xmlMeasurementId \" is \" none \" Then save response payload \" //measurement[0]/id/text() \" that matches \" ^cpu[\\\\d]+$ \" in \" xmlMeasurementId \" Arguments : target enum - \"metadata\" or \"payload\", depending on which part of the response should be used expression str - JSON path or XPath expression for finding the property match_with str - static value or a regular expression variable str - name of the already initialized variable to save the value in step_response_save @then ( u 'save response {target:ResponseTarget} \" {expression} \" in variable \" {variable} \"' ) def step_response_save ( context : Context , target : ResponseTarget , expression : str , variable : str ) -> None Save metadata (header) or payload (body) value from a response in a variable. This step is the same as step_response_save_matches if match_with is set to .* . With this step it is possible to change variable values and as such use values from a response later on in the load test. This step will fail if the specified expression has no match or more than one match. Then save response metadata \" $.Authentication \" in variable \" HEADER_AUTHENTICATION \" Then save response payload \" $.Result.ShipmentId \" in variable \" ShipmentId \" Then save response payload \" //measurement[0]/id/text() \" in \" xmlMeasurementId \" Arguments : target enum - \"metadata\" or \"payload\", depending on which part of the response should be used expression str - JSON path or XPath expression for finding the property variable str - name of the already initialized variable to save the value in step_response_validate @when ( u 'response {target:ResponseTarget} \" {expression} \" {condition:Condition} \" {match_with} \" stop user' ) def step_response_validate ( context : Context , target : ResponseTarget , expression : str , condition : bool , match_with : str ) -> None Fails the scenario based on the value of a response meta data (header) or payload (body). When response metadata \" $.['content-type'] \" is not \" .*application/json.* \" stop user When response metadata \" $.['x-test-command'] \" is \" abort \" stop user When response metadata \" $.Authentication \" is not \" Bearer .*$ \" stop user When response payload \" $.measurement.id \" is not \" cpu[0-9]+ \" stop user When response payload \" $.success \" is \" false \" stop user When response payload \" /root/measurement[@id= \"cpu\" ]/success/text() \" is \" 'false' \" stop user Arguments : target enum - \"metadata\" or \"payload\", depending on which part of the response should be used expression str - JSON path or XPath expression for finding the property condition enum - \"is\" or \"is not\" depending on negative or postive matching match_with str - static value or a regular expression step_response_allow_status_codes @then ( u 'allow response status codes \" {status_list} \"' ) def step_response_allow_status_codes ( context : Context , status_list : str ) -> None Set allowed response status codes for the latest defined request in the scenario. By default 200 is the only allowed respoonse status code. By prefixing a code with minus ( - ), it will be removed from the list of allowed response status codes. Then get request with name \" test-get-1 \" from endpoint \" /api/test \" And allow response status \" 200,302 \" Then get request with name \" test-failed-get-2 \" from endpoint \" /api/non-existing \" And allow response status \" -200,404 \" Arguments : status_list str - comma separated list of integers step_response_allow_status_codes_table @then ( u 'allow response status codes' ) def step_response_allow_status_codes_table ( context : Context ) -> None Set allowed response status codes for the latest defined requests based on a data table. Specifies a comma separeated list of allowed return codes for the latest requests in a data table. By default 200 is the only allowed respoonse status code. By prefixing a code with minus ( - ), it will be removed from the list of allowed response status codes. Number of rows in the table specifies which of the latest defined requests the allowed response status codes should map to. The table must have the column header status . Then get request with name \" test-get-1 \" from endpoint \" /api/test \" Then get request with name \" test-get-2 \" from endpoint \" /api/test \" And allow response status | status | | 200, 302 | | 200,404 | Allowed response status codes for test-get-1 is now 200 and 302 , and for test-get-2 is now 200 and 404 . step_response_content_type @then ( u 'set response content type to \"{content_type:ResponseContentType}\"' ) def step_response_content_type ( context : Context , content_type : ResponseContentType ) -> None Set the content type of a response, instead of guessing it. This is applicable when there is a step_response_validate or step_response_save is included in the scenario, and is valid only for the latest defined request. And set response content type to \" json \" And set response content type to \" application/json \" And set response content type to \" xml \" And set response content type to \" application/xml \" And set response content type to \" plain \" And set response content type to \" text/plain \" Arguments : content_type ResponseContentType - expected content type of response grizzly.steps.scenario.results This module contains step implementations that validates the response results for all requests in a scenario. step_results_fail_ratio @when ( u 'fail ratio is greater than \" {fail_ratio:d} \" % f ail scenario' ) def step_results_fail_ratio ( context : Context , fail_ratio : int ) -> None Set how many percentages of requests that are allowed to fail before the whole scenario will be set as failed. This step cannot be used in combination with step_setup_enable_stop_on_failure . Default behavior is not to validate the result for a scenario based on failed requests. When fail ratio is greater than \" 8 \"% fail scenario Arguments : fail_ratio int - percentage of requests that are allowed to fail step_results_avg_response_time @when ( u 'average response time is greater than \" {avg_response_time:d} \" milliseconds fail scenario' ) def step_results_avg_response_time ( context : Context , avg_response_time : int ) -> None Set the average response time (milliseconds) that all requests in a scenario must be below for it to pass. Default behavior is not to validate the result for a scenario based on average response time. When average response time is greater than \" 200 \" milliseconds fail scenario Arguments : avg_response_time int - allowed average response time in milliseconds step_results_response_time_percentile @when ( u 'response time percentile \" {percentile:d} \" % i s greater than \" {response_time:d} \" milliseconds fail scenario' ) def step_results_response_time_percentile ( context : Context , percentile : float , response_time : int ) -> None Set the response time that a specified percentile of the requests needs to be below for the scenario to pass. Default behavior is not to validate the result for a scenario based on percetile response times. When response time percentile \" 95 \"% is greater than \" 200 \" milliseconds fail scenario Arguments : percentile int - percentile to validate (1-100) response_time int - response time in milliseconds grizzly.steps.scenario.user This module contains step implementations that describes a user. step_user_type @given ( u 'a user of type \" {user_class_name} \" load testing \" {host} \"' ) def step_user_type ( context : Context , user_class_name : str , host : str ) -> None Set which type of user the scenario should use and which host is the target. Given a user of type \" RestApi \" load testing \" http://api.google.com \" Given a user of type \" MessageQueue \" load testing \" mq://mqm:secret@mq.example.com/?QueueManager=QMGR01&Channel=Channel01 \" Given a user of type \" ServiceBus \" load testing \" sb://sb.example.com/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=abc123def456ghi789= \" Given a user of type \" BlobStorage \" load testing \" DefaultEndpointsProtocol=https;EndpointSuffix=core.windows.net;AccountName=examplestorage;AccountKey=xxxyyyyzzz== \" Arguments : user_class_name str - name of an implementation in grizzly.users , with or without User host str - an URL for the target host, format depends on which user_class_name (see grizzly.users ) grizzly.steps.scenario.tasks This module contains step implementations that describes requests sent by user_class_name targeting host . step_task_request_text_with_name_to_endpoint @then ( u '{method:Method} request with name \" {name} \" {direction:Direction} endpoint \" {endpoint} \"' ) def step_task_request_text_with_name_to_endpoint ( context : Context , method : RequestMethod , name : str , direction : RequestDirection , endpoint : str ) -> None Creates a named request to an endpoint on host , where optional payload is defined directly in the feature file. If method in the expression is get or receive ; the direction must be from . If method in the expression is post , pust , or send ; the direction must be to , and payload defined in the feature file. Then post request with name \" test-post \" to endpoint \" /api/test \" \"\"\" { \"test\": \"hello world\" } \"\"\" Then put request with name \" test-post \" to endpoint \" /api/test \" \"\"\" { \"test\": \"hello world\" } \"\"\" Then get request with name \" test-get \" from endpoint \" /api/test \" Then send request with name \" test-send \" to endpoint \" receive-queue \" \"\"\" { \"value\": \"do something\" } \"\"\" Then receive request with name \" test-receive \" from endpoint \" receive-queue \" Arguments : method RequestMethod - type of request name str - name of the requests in logs, can contain variables direction RequestDirection - one of to or from depending on the value of method endpoint str - URI relative to host in the scenario, can contain variables and in certain cases user_class_name specific parameters step_task_request_file_with_name_endpoint @then ( u '{method:Method} request \" {source} \" with name \" {name} \" to endpoint \" {endpoint} \"' ) def step_task_request_file_with_name_endpoint ( context : Context , method : RequestMethod , source : str , name : str , endpoint : str ) -> None Creates a named request to an endpoint on host , where the payload is defined in a template file. Then send request \" test/request.j2.json \" with name \" test-send \" to endpoint \" receive-queue \" Then post request \" test/request.j2.json \" with name \" test-post \" to endpoint \" /api/test \" Then put request \" test/request.j2.json \" with name \" test-put \" to endpoint \" /api/test \" Arguments : method RequestMethod - type of request source str - path to a template file relative to the directory requests/ , which must exist in the directory the feature file is located name str - name of the requests in logs, can contain variables endpoint str - URI relative to host in the scenario, can contain variables and in certain cases user_class_name specific parameters step_task_request_file_with_name @then ( u '{method:Method} request \" {source} \" with name \" {name} \"' ) def step_task_request_file_with_name ( context : Context , method : RequestMethod , source : str , name : str ) -> None Creates a named request to the same endpoint as previous request, where the payload is defined in a template file. Then post request \" test/request1.j2.json \" with name \" test-post1 \" to endpoint \" /api/test \" Then post request \" test/request2.j2.json \" with name \" test-post2 \" # same as Then post request \" test/request1.j2.json \" with name \" test-post1 \" to endpoint \" /api/test \" Then post request \" test/request2.j2.json \" with name \" test-post2 \" to endpoint \" /api/test \" Arguments : method RequestMethod - type of request source str - path to a template file relative to the directory requests/ , which must exist in the directory the feature file is located name str - name of the requests in logs, can contain variables step_task_request_text_with_name @then ( u '{method:Method} request with name \" {name} \"' ) def step_task_request_text_with_name ( context : Context , method : RequestMethod , name : str ) -> None Creates a named request to the same endpoint as previous request, where optional payload is defined directly in the feature file. If method in the expression is post , put or send the payload in the request must be defined directly in the feature file after the step. This step is useful if method and endpoint are the same as previous request, but the payload should be different. Then post request with name \" test-post-1 \" to endpoint \" /api/test \" \"\"\" { \"value\": \"hello world!\" } \"\"\" Then post request with name \" test-post-2 \" \"\"\" { \"value\": \"i have good news!\" } \"\"\" # same as Then post request with name \" test-post-1 \" to endpoint \" /api/test \" \"\"\" { \"value\": \"hello world!\" } \"\"\" Then post request with name \" test-post-2 \" to endpoint \" /api/test \" \"\"\" { \"value\": \"i have good news!\" } \"\"\" Then get request with name \" test-get-1 \" from endpoint \" /api/test \" Then get request with name \" test-get-2 \" # same as Then get request with name \" test-get-1 \" from endpoint \" /api/test \" Then get request with name \" test-get-2 \" from endpoint \" /api/test \" Arguments : method RequestMethod - type of request name str - name of the requests in logs, can contain variables step_task_wait_seconds @then ( u 'wait for \" {wait_time:f} \" seconds' ) def step_task_wait_seconds ( context : Context , wait_time : float ) -> None Create an explicit wait (task) in the scenario. The scenario will wait the time specified (seconds) on top of what has been defined in step_setup_wait_time . Above combinations of steps will result in a wait time between 3 and 4 seconds for the first request that is defined after the And wait for... -step. And wait time inbetween requests is random between \" 1.5 \" and \" 2.5 \" seconds ... And wait for \" 1.5 \" seconds Arguments : wait_time float - wait time in seconds step_task_print_message @then ( u 'print message \" {message} \"' ) def step_task_print_message ( context : Context , message : str ) -> None Print a message in the scenario. Useful for visualizing values of variables. The message can be a jinja template, and any variables will be rendered at the time the task executes. And print message \" context_variable='{{ context_variable }}' Arguments : message str - message to print grizzly.steps.background This package contains step implementations that only is allowed in the Background section in a Feature . The feature will fail if they are added into any other section. grizzly.steps.background.shapes This module contains step implementations that describes the actual load all scenarios in a feature will generate. step_shapes_user_count @given ( u '\" {user_count:d} \" {user_number:UserGramaticalNumber}' ) def step_shapes_user_count ( context : Context , user_count : int , user_number : str ) -> None Set number of users that will generate load. Given \" 5 \" users Given \" 1 \" user Given \" $conf::load.user.count \" Arguments : user_count int - Number of users locust should create step_shapes_spawn_rate @given ( u 'spawn rate is \" {spawn_rate:d} \" {user_number:UserGramaticalNumber} per second' ) def step_shapes_spawn_rate ( context : Context , spawn_rate : int , user_number : str ) -> None Set rate in which locust shall swarm new user instances. And spawn rate is \" 5 \" users per second And spawn rate is \" 1 \" user per second Arguments : spawn_rate int - number of users per second grizzly.steps.background.setup This module contains step implementations that configures the load test scenario with parameters applicable for all scenarios. step_setup_save_statistics @given ( u 'save statistics to \" {url} \"' ) def step_setup_save_statistics ( context : Context , url : str ) -> None Sets an URL where locust statistics should be sent. It has support for InfluxDB and Azure Application Insights endpoints. For InfluxDB the following format must be used: For Azure Application Insights the following format must be used: influxdb://[<username>:<password>@]<hostname>[:<port>]/<database>?TargetEnviroment=<target environment>[&Testplan=<test plan>] [&TargetEnvironment=<target environment>][&ProfileName=<profile name>][&Description=<description>] insights://?InstrumentationKey=<instrumentation key>&IngestionEndpoint=<ingestion endpoint>[&Testplan=<test plan>] insights://<ingestion endpoint>/?InstrumentationKey=<instrumentation key>[&Testplan=<test plan>] And save statistics to \" influxdb://grizzly:secret-password@influx.example.com/grizzly-statistics \" And save statistics to \" insights://?IngestionEndpoint=https://insights.example.com&Testplan=grizzly-statistics&InstrumentationKey=asdfasdfasdf= \" And save statistics to \" insights://insights.example.com/?Testplan=grizzly-statistics&InstrumentationKey=asdfasdfasdf= \" And save statistics to \" influxdb://$conf::statistics.username:$conf::statistics.password@influx.example.com/$conf::statistics.database \" Arguments : url str - URL for statistics endpoint step_setup_log_level @given ( u 'log level is \" {log_level} \"' ) def step_setup_log_level ( context : Context , log_level : str ) -> None Configure log level for grizzly . Default value is INFO , by changing to DEBUG there is more information what grizzly is doing behind the curtains. And log level is \" DEBUG \" Arguments : log_level str - allowed values INFO , DEBUG , WARNING och ERROR step_setup_run_time @given ( u 'run for maximum \" {timespan} \"' ) def step_setup_run_time ( context : Context , timespan : str ) -> None Configures the time period a headless test should run for. If available test data is infinite, the test will run forever if this step is not used. And run for maximum \" 1h \" Arguments : timespan str - description of how long the test should run for, e.g. 10s, 1h, 40m etc. step_setup_set_global_context_variable @given ( u 'set global context variable \" {variable} \" to \" {value} \"' ) def step_setup_set_global_context_variable ( context : Context , variable : str , value : str ) -> None Create a global variable in the context. Depending on which type of user a scenario is configured for, different variables are available. Check grizzly.users documentation for which context variables are available for each user. This step can be used if the feature file has multiple scenarios and all of them have the same context variables. Variable names can contain (one ore more) dot ( . ) or slash ( / ) to indicate that the variable is in a structure. All names will also be converted to lower case. E.g. token.url and token/URL results in: Space in variable names is also allowed and will then be translated to an underscore ( _ ) E.g. Client ID results in client_id . Data type of values will be guessed, if not explicitly specified by the type of variable used ( Atomic* ). E.g. the last two examples above will result in: { ' t oke n ' : { 'url' : '<value>' } } And set global context variable \" token.url \" to \" http://test.nu/api/auth \" And set global context variable \" token/client_id \" to \" aaaa-bbbb-cccc-dddd \" And set global context variable \" token/client secret \" to \" aasdfasdfasdf== \" And set global context variable \" token.resource \" to \" 0000-aaaaaaa-1111-1111-1111 \" And set global context variable \" log_all_requests \" to \" True \" And set global context variable \" validate_certificates \" to \" False \" And set global context variable \" run_id \" to \" 13 \" { 'valida te _cer t i f ica tes ' : False , 'ru n _id' : 13 } Arguments : variable str - variable name, as used in templates value str - variable value grizzly.steps.utils This package contains steps that can be useful during development or troubleshooting of a feature file, but should not be included in a finished, testable, feature. step_utils_fail @then ( u 'fail' ) def step_utils_fail ( context : Context ) -> None Force a failed scenario. Can be useful when writing a new scenario. Then fail","title":"Anywhere"},{"location":"usage/steps/anywhere/#grizzlystepssetup","text":"","title":"grizzly.steps.setup"},{"location":"usage/steps/anywhere/#step_setup_variable_value_ask","text":"@given ( u 'ask for value of variable \" {name} \"' ) def step_setup_variable_value_ask ( context : Context , name : str ) -> None This step is used to indicate for grizzly-cli that it should ask for an initial value for the variable. It will then inject the value into the locust runtime environment, and in this step read it and insert it into the locust context which grizzly will use to setup locust. If grizzly-cli is not used, one has to manually set the environment variable, which requires a prefix of TESTDATA_VARIABLE_ and the suffix should match the variable name in question. Use this step for variables that should have different initial values for each run of the feature. And ask for value for variable \" AtomicIntegerIncrementer.messageID \" Arguments : name str - variable name used in templates","title":"step_setup_variable_value_ask"},{"location":"usage/steps/anywhere/#grizzlystepsscenario","text":"This package contains step implementations that only is allowed in the Scenario section in a feature file.","title":"grizzly.steps.scenario"},{"location":"usage/steps/anywhere/#grizzlystepsscenariosetup","text":"This module contains step implementations that setup the load test scenario with parameters that is going to be used in the scenario they are defined in.","title":"grizzly.steps.scenario.setup"},{"location":"usage/steps/anywhere/#step_setup_set_context_variable","text":"@given ( u 'set context variable \" {variable} \" to \" {value} \"' ) def step_setup_set_context_variable ( context : Context , variable : str , value : str ) -> None Set a variable in the scenario context. Variable name can contain (one or more) dot ( . ) or slash ( / ) to indicate that the variable has a nested structure. E.g. token.url and token/url results in: It is also possible to have spaces in a variable name, they will then be replaced with underscore ( _ ), and name will be converted to lowercase. E.g. Client ID results in client_id { ' t oke n ' : { 'url' : '<value>' } } And set context variable \" token.url \" to \" https://example.com/api/auth \" And set context variable \" token/client_id \" to \" aaaa-bbbb-cccc-dddd \" And set context variable \" token/client secret \" to \" aasdfasdfasdf== \" And set context variable \" token.resource \" to \" 0000-aaaaaaa-1111-1111-1111 \" And set context variable \" log_all_requests \" to \" True \" And set context variable \" validate_certificates \" to \" False \" Arguments : variable str - name, can contain . and / value str - value, data type will be guessed and casted","title":"step_setup_set_context_variable"},{"location":"usage/steps/anywhere/#step_setup_iterations","text":"@given ( u 'repeat for \" {value} \" {iteration_number:IterationGramaticalNumber}' ) def step_setup_iterations ( context : Context , value : str , iteration_number : str ) -> None Set how many iterations of the requests in the scenario should execute. Default value is 1 . A value of 0 means to run until all test data is consumed, or that the (optional) specified runtime for the scenario is reached. And repeat for \" 10 \" iterations And repeat for \" 1 \" iteration And value for variable \" leveranser \" is \" 100 \" And repeat for \" {{ leveranser * 0.25 }} \" iterations Arguments : iterations int - number of iterations of the scenario","title":"step_setup_iterations"},{"location":"usage/steps/anywhere/#step_setup_wait_time","text":"@given ( u 'wait time inbetween requests is random between \" {minimum:f} \" and \" {maximum:f} \" seconds' ) def step_setup_wait_time ( context : Context , minimum : float , maximum : float ) -> None Set how long (seconds) locust should wait between tasks. Default value is 1.0 seconds. Set wait_min = wait_max if the wait shouldn't be random in the specified interval. And wait time inbetween requests is random between \" 0.3 \" and \" 0.5 \" seconds Arguments : wait_min float - minimum wait time wait_max float - maximum wait time","title":"step_setup_wait_time"},{"location":"usage/steps/anywhere/#step_setup_variable_value","text":"@given ( u 'value for variable \" {name} \" is \" {value} \"' ) def step_setup_variable_value ( context : Context , name : str , value : str ) -> None Initialize a variable. Use this step to initialize a variable that should have the same [start] value for every run of the scenario. Data type for the value of the variable is based on the type of variable. If the variable is an \" Atomic* \"-variable then the value needs to match the format and type that the variable has implemented. If it is a non \" Atomic* \"-variable grizzly will try to guess the data type. E.g.: * \"10\" becomes int * \"1.0\" becomes float * \"True\" becomes bool * everything else becomes str It is possible to set the value of a variable based on another variable, which can be usable if you have a variable in multiple scenarios which all should have the same initial value. And value for variable \" HelloWorld \" is \" default \" Feature: Background: And ask for value of variable \" messageID \" Scenario: And value for variable \" AtomicIntegerIncrementer.mid1 \" is \" {{ messageID }} \" Arguments : name str - variable name value Any - initial value","title":"step_setup_variable_value"},{"location":"usage/steps/anywhere/#step_setup_set_variable_alias","text":"@given ( u 'set alias \" {alias} \" for variable \" {variable} \"' ) def step_setup_set_variable_alias ( context : Context , alias : str , variable : str ) -> None Create an alias for a variable that points to another structure in the context. This is useful if you have test data that somehow should change the behavior for a user, e.g. username and password. Assumed that the file users.csv contains the columns username and password ; without the alias step it would look like the following structure in the context: With the alias step it will be transformed to this: Variables in payload templates are not allowed to have an alias. And set variable \" AtomicCsvRow.users \" to \" users.csv | repeat=True \" And set alias \" auth.user.username \" for variable \" AtomicCsvRow.users.username \" And set alias \" auth.user.password \" for variable \" AtomicCsvRow.users.password \" { \"variables\" : { \"AtomicCsvRow\" : { \"users\" : { \"username\" : \"username\" , \"password\" : \"password\" } } } } { \"auth\" : { \"user\" : { \"username\" : \"username\" , \"password\" : \"password\" } } } Arguments : alias str - which node in the context that should get the value of variable variable str - an already initialized variable that should be renamed","title":"step_setup_set_variable_alias"},{"location":"usage/steps/anywhere/#step_setup_log_all_requests","text":"@given ( u 'log all requests' ) def step_setup_log_all_requests ( context : Context ) -> None Set if all requests should be logged to a file. By default only failed requests (and responses) will be logged. And log all requests","title":"step_setup_log_all_requests"},{"location":"usage/steps/anywhere/#step_setup_enable_stop_on_failure","text":"@given ( u 'stop on first failure' ) def step_setup_enable_stop_on_failure ( context : Context ) -> None Stop a scenario at first failed request. Default behavior is to continue the scenario if a request fails. And stop on first failure","title":"step_setup_enable_stop_on_failure"},{"location":"usage/steps/anywhere/#grizzlystepsscenarioresponse","text":"This module contains step implementations that handles request responses.","title":"grizzly.steps.scenario.response"},{"location":"usage/steps/anywhere/#step_response_save_matches","text":"@then ( u 'save response {target:ResponseTarget} \" {expression} \" that matches \" {match_with} \" in variable \" {variable} \"' ) def step_response_save_matches ( context : Context , target : ResponseTarget , expression : str , match_with : str , variable : str ) -> None Save specified parts of a response, either from meta data (header) or payload (body), in a variable. With this step it is possible to change variable values and as such use values from a response later on in the load test. This step will fail if the specified expression has no match or more than one match. # only token is matched and saved in TOKEN, by using regexp match groups And value of variable \" TOKEN \" is \" none \" Then save response metadata \" $.Authentication \" that matches \" Bearer (.*)$ \" in variabel \" TOKEN \" # the whole value is saved, as long as Authentication starts with \"Bearer\" And value of variable \" HEADER_AUTHENTICATION \" is \" none \" Then save response metadata \" $.Authentication \" that matches \" ^Bearer .*$ \" in variable \" HEADER_AUTHENTICATION \" # only the numerical suffix is saved in the variable And value of variable \" AtomicInteger.measurermentId \" is \" 0 \" Then save response payload \" $.measurement.id \" that matches \" ^cpu([\\\\d]+)$ \" in \" AtomicInteger.measurementId \" # the whole value is saved, as long as the value starts with \"cpu\" And value of variable \" measurementId \" is \" 0 \" Then save response payload \" $.measurement.id \" that matches \" ^cpu[\\\\d]+$ \" in \" measurementId \" # xpath example And set response content type to \" application/xml \" And value of variable \" xmlMeasurementId \" is \" none \" Then save response payload \" //measurement[0]/id/text() \" that matches \" ^cpu[\\\\d]+$ \" in \" xmlMeasurementId \" Arguments : target enum - \"metadata\" or \"payload\", depending on which part of the response should be used expression str - JSON path or XPath expression for finding the property match_with str - static value or a regular expression variable str - name of the already initialized variable to save the value in","title":"step_response_save_matches"},{"location":"usage/steps/anywhere/#step_response_save","text":"@then ( u 'save response {target:ResponseTarget} \" {expression} \" in variable \" {variable} \"' ) def step_response_save ( context : Context , target : ResponseTarget , expression : str , variable : str ) -> None Save metadata (header) or payload (body) value from a response in a variable. This step is the same as step_response_save_matches if match_with is set to .* . With this step it is possible to change variable values and as such use values from a response later on in the load test. This step will fail if the specified expression has no match or more than one match. Then save response metadata \" $.Authentication \" in variable \" HEADER_AUTHENTICATION \" Then save response payload \" $.Result.ShipmentId \" in variable \" ShipmentId \" Then save response payload \" //measurement[0]/id/text() \" in \" xmlMeasurementId \" Arguments : target enum - \"metadata\" or \"payload\", depending on which part of the response should be used expression str - JSON path or XPath expression for finding the property variable str - name of the already initialized variable to save the value in","title":"step_response_save"},{"location":"usage/steps/anywhere/#step_response_validate","text":"@when ( u 'response {target:ResponseTarget} \" {expression} \" {condition:Condition} \" {match_with} \" stop user' ) def step_response_validate ( context : Context , target : ResponseTarget , expression : str , condition : bool , match_with : str ) -> None Fails the scenario based on the value of a response meta data (header) or payload (body). When response metadata \" $.['content-type'] \" is not \" .*application/json.* \" stop user When response metadata \" $.['x-test-command'] \" is \" abort \" stop user When response metadata \" $.Authentication \" is not \" Bearer .*$ \" stop user When response payload \" $.measurement.id \" is not \" cpu[0-9]+ \" stop user When response payload \" $.success \" is \" false \" stop user When response payload \" /root/measurement[@id= \"cpu\" ]/success/text() \" is \" 'false' \" stop user Arguments : target enum - \"metadata\" or \"payload\", depending on which part of the response should be used expression str - JSON path or XPath expression for finding the property condition enum - \"is\" or \"is not\" depending on negative or postive matching match_with str - static value or a regular expression","title":"step_response_validate"},{"location":"usage/steps/anywhere/#step_response_allow_status_codes","text":"@then ( u 'allow response status codes \" {status_list} \"' ) def step_response_allow_status_codes ( context : Context , status_list : str ) -> None Set allowed response status codes for the latest defined request in the scenario. By default 200 is the only allowed respoonse status code. By prefixing a code with minus ( - ), it will be removed from the list of allowed response status codes. Then get request with name \" test-get-1 \" from endpoint \" /api/test \" And allow response status \" 200,302 \" Then get request with name \" test-failed-get-2 \" from endpoint \" /api/non-existing \" And allow response status \" -200,404 \" Arguments : status_list str - comma separated list of integers","title":"step_response_allow_status_codes"},{"location":"usage/steps/anywhere/#step_response_allow_status_codes_table","text":"@then ( u 'allow response status codes' ) def step_response_allow_status_codes_table ( context : Context ) -> None Set allowed response status codes for the latest defined requests based on a data table. Specifies a comma separeated list of allowed return codes for the latest requests in a data table. By default 200 is the only allowed respoonse status code. By prefixing a code with minus ( - ), it will be removed from the list of allowed response status codes. Number of rows in the table specifies which of the latest defined requests the allowed response status codes should map to. The table must have the column header status . Then get request with name \" test-get-1 \" from endpoint \" /api/test \" Then get request with name \" test-get-2 \" from endpoint \" /api/test \" And allow response status | status | | 200, 302 | | 200,404 | Allowed response status codes for test-get-1 is now 200 and 302 , and for test-get-2 is now 200 and 404 .","title":"step_response_allow_status_codes_table"},{"location":"usage/steps/anywhere/#step_response_content_type","text":"@then ( u 'set response content type to \"{content_type:ResponseContentType}\"' ) def step_response_content_type ( context : Context , content_type : ResponseContentType ) -> None Set the content type of a response, instead of guessing it. This is applicable when there is a step_response_validate or step_response_save is included in the scenario, and is valid only for the latest defined request. And set response content type to \" json \" And set response content type to \" application/json \" And set response content type to \" xml \" And set response content type to \" application/xml \" And set response content type to \" plain \" And set response content type to \" text/plain \" Arguments : content_type ResponseContentType - expected content type of response","title":"step_response_content_type"},{"location":"usage/steps/anywhere/#grizzlystepsscenarioresults","text":"This module contains step implementations that validates the response results for all requests in a scenario.","title":"grizzly.steps.scenario.results"},{"location":"usage/steps/anywhere/#step_results_fail_ratio","text":"@when ( u 'fail ratio is greater than \" {fail_ratio:d} \" % f ail scenario' ) def step_results_fail_ratio ( context : Context , fail_ratio : int ) -> None Set how many percentages of requests that are allowed to fail before the whole scenario will be set as failed. This step cannot be used in combination with step_setup_enable_stop_on_failure . Default behavior is not to validate the result for a scenario based on failed requests. When fail ratio is greater than \" 8 \"% fail scenario Arguments : fail_ratio int - percentage of requests that are allowed to fail","title":"step_results_fail_ratio"},{"location":"usage/steps/anywhere/#step_results_avg_response_time","text":"@when ( u 'average response time is greater than \" {avg_response_time:d} \" milliseconds fail scenario' ) def step_results_avg_response_time ( context : Context , avg_response_time : int ) -> None Set the average response time (milliseconds) that all requests in a scenario must be below for it to pass. Default behavior is not to validate the result for a scenario based on average response time. When average response time is greater than \" 200 \" milliseconds fail scenario Arguments : avg_response_time int - allowed average response time in milliseconds","title":"step_results_avg_response_time"},{"location":"usage/steps/anywhere/#step_results_response_time_percentile","text":"@when ( u 'response time percentile \" {percentile:d} \" % i s greater than \" {response_time:d} \" milliseconds fail scenario' ) def step_results_response_time_percentile ( context : Context , percentile : float , response_time : int ) -> None Set the response time that a specified percentile of the requests needs to be below for the scenario to pass. Default behavior is not to validate the result for a scenario based on percetile response times. When response time percentile \" 95 \"% is greater than \" 200 \" milliseconds fail scenario Arguments : percentile int - percentile to validate (1-100) response_time int - response time in milliseconds","title":"step_results_response_time_percentile"},{"location":"usage/steps/anywhere/#grizzlystepsscenariouser","text":"This module contains step implementations that describes a user.","title":"grizzly.steps.scenario.user"},{"location":"usage/steps/anywhere/#step_user_type","text":"@given ( u 'a user of type \" {user_class_name} \" load testing \" {host} \"' ) def step_user_type ( context : Context , user_class_name : str , host : str ) -> None Set which type of user the scenario should use and which host is the target. Given a user of type \" RestApi \" load testing \" http://api.google.com \" Given a user of type \" MessageQueue \" load testing \" mq://mqm:secret@mq.example.com/?QueueManager=QMGR01&Channel=Channel01 \" Given a user of type \" ServiceBus \" load testing \" sb://sb.example.com/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=abc123def456ghi789= \" Given a user of type \" BlobStorage \" load testing \" DefaultEndpointsProtocol=https;EndpointSuffix=core.windows.net;AccountName=examplestorage;AccountKey=xxxyyyyzzz== \" Arguments : user_class_name str - name of an implementation in grizzly.users , with or without User host str - an URL for the target host, format depends on which user_class_name (see grizzly.users )","title":"step_user_type"},{"location":"usage/steps/anywhere/#grizzlystepsscenariotasks","text":"This module contains step implementations that describes requests sent by user_class_name targeting host .","title":"grizzly.steps.scenario.tasks"},{"location":"usage/steps/anywhere/#step_task_request_text_with_name_to_endpoint","text":"@then ( u '{method:Method} request with name \" {name} \" {direction:Direction} endpoint \" {endpoint} \"' ) def step_task_request_text_with_name_to_endpoint ( context : Context , method : RequestMethod , name : str , direction : RequestDirection , endpoint : str ) -> None Creates a named request to an endpoint on host , where optional payload is defined directly in the feature file. If method in the expression is get or receive ; the direction must be from . If method in the expression is post , pust , or send ; the direction must be to , and payload defined in the feature file. Then post request with name \" test-post \" to endpoint \" /api/test \" \"\"\" { \"test\": \"hello world\" } \"\"\" Then put request with name \" test-post \" to endpoint \" /api/test \" \"\"\" { \"test\": \"hello world\" } \"\"\" Then get request with name \" test-get \" from endpoint \" /api/test \" Then send request with name \" test-send \" to endpoint \" receive-queue \" \"\"\" { \"value\": \"do something\" } \"\"\" Then receive request with name \" test-receive \" from endpoint \" receive-queue \" Arguments : method RequestMethod - type of request name str - name of the requests in logs, can contain variables direction RequestDirection - one of to or from depending on the value of method endpoint str - URI relative to host in the scenario, can contain variables and in certain cases user_class_name specific parameters","title":"step_task_request_text_with_name_to_endpoint"},{"location":"usage/steps/anywhere/#step_task_request_file_with_name_endpoint","text":"@then ( u '{method:Method} request \" {source} \" with name \" {name} \" to endpoint \" {endpoint} \"' ) def step_task_request_file_with_name_endpoint ( context : Context , method : RequestMethod , source : str , name : str , endpoint : str ) -> None Creates a named request to an endpoint on host , where the payload is defined in a template file. Then send request \" test/request.j2.json \" with name \" test-send \" to endpoint \" receive-queue \" Then post request \" test/request.j2.json \" with name \" test-post \" to endpoint \" /api/test \" Then put request \" test/request.j2.json \" with name \" test-put \" to endpoint \" /api/test \" Arguments : method RequestMethod - type of request source str - path to a template file relative to the directory requests/ , which must exist in the directory the feature file is located name str - name of the requests in logs, can contain variables endpoint str - URI relative to host in the scenario, can contain variables and in certain cases user_class_name specific parameters","title":"step_task_request_file_with_name_endpoint"},{"location":"usage/steps/anywhere/#step_task_request_file_with_name","text":"@then ( u '{method:Method} request \" {source} \" with name \" {name} \"' ) def step_task_request_file_with_name ( context : Context , method : RequestMethod , source : str , name : str ) -> None Creates a named request to the same endpoint as previous request, where the payload is defined in a template file. Then post request \" test/request1.j2.json \" with name \" test-post1 \" to endpoint \" /api/test \" Then post request \" test/request2.j2.json \" with name \" test-post2 \" # same as Then post request \" test/request1.j2.json \" with name \" test-post1 \" to endpoint \" /api/test \" Then post request \" test/request2.j2.json \" with name \" test-post2 \" to endpoint \" /api/test \" Arguments : method RequestMethod - type of request source str - path to a template file relative to the directory requests/ , which must exist in the directory the feature file is located name str - name of the requests in logs, can contain variables","title":"step_task_request_file_with_name"},{"location":"usage/steps/anywhere/#step_task_request_text_with_name","text":"@then ( u '{method:Method} request with name \" {name} \"' ) def step_task_request_text_with_name ( context : Context , method : RequestMethod , name : str ) -> None Creates a named request to the same endpoint as previous request, where optional payload is defined directly in the feature file. If method in the expression is post , put or send the payload in the request must be defined directly in the feature file after the step. This step is useful if method and endpoint are the same as previous request, but the payload should be different. Then post request with name \" test-post-1 \" to endpoint \" /api/test \" \"\"\" { \"value\": \"hello world!\" } \"\"\" Then post request with name \" test-post-2 \" \"\"\" { \"value\": \"i have good news!\" } \"\"\" # same as Then post request with name \" test-post-1 \" to endpoint \" /api/test \" \"\"\" { \"value\": \"hello world!\" } \"\"\" Then post request with name \" test-post-2 \" to endpoint \" /api/test \" \"\"\" { \"value\": \"i have good news!\" } \"\"\" Then get request with name \" test-get-1 \" from endpoint \" /api/test \" Then get request with name \" test-get-2 \" # same as Then get request with name \" test-get-1 \" from endpoint \" /api/test \" Then get request with name \" test-get-2 \" from endpoint \" /api/test \" Arguments : method RequestMethod - type of request name str - name of the requests in logs, can contain variables","title":"step_task_request_text_with_name"},{"location":"usage/steps/anywhere/#step_task_wait_seconds","text":"@then ( u 'wait for \" {wait_time:f} \" seconds' ) def step_task_wait_seconds ( context : Context , wait_time : float ) -> None Create an explicit wait (task) in the scenario. The scenario will wait the time specified (seconds) on top of what has been defined in step_setup_wait_time . Above combinations of steps will result in a wait time between 3 and 4 seconds for the first request that is defined after the And wait for... -step. And wait time inbetween requests is random between \" 1.5 \" and \" 2.5 \" seconds ... And wait for \" 1.5 \" seconds Arguments : wait_time float - wait time in seconds","title":"step_task_wait_seconds"},{"location":"usage/steps/anywhere/#step_task_print_message","text":"@then ( u 'print message \" {message} \"' ) def step_task_print_message ( context : Context , message : str ) -> None Print a message in the scenario. Useful for visualizing values of variables. The message can be a jinja template, and any variables will be rendered at the time the task executes. And print message \" context_variable='{{ context_variable }}' Arguments : message str - message to print","title":"step_task_print_message"},{"location":"usage/steps/anywhere/#grizzlystepsbackground","text":"This package contains step implementations that only is allowed in the Background section in a Feature . The feature will fail if they are added into any other section.","title":"grizzly.steps.background"},{"location":"usage/steps/anywhere/#grizzlystepsbackgroundshapes","text":"This module contains step implementations that describes the actual load all scenarios in a feature will generate.","title":"grizzly.steps.background.shapes"},{"location":"usage/steps/anywhere/#step_shapes_user_count","text":"@given ( u '\" {user_count:d} \" {user_number:UserGramaticalNumber}' ) def step_shapes_user_count ( context : Context , user_count : int , user_number : str ) -> None Set number of users that will generate load. Given \" 5 \" users Given \" 1 \" user Given \" $conf::load.user.count \" Arguments : user_count int - Number of users locust should create","title":"step_shapes_user_count"},{"location":"usage/steps/anywhere/#step_shapes_spawn_rate","text":"@given ( u 'spawn rate is \" {spawn_rate:d} \" {user_number:UserGramaticalNumber} per second' ) def step_shapes_spawn_rate ( context : Context , spawn_rate : int , user_number : str ) -> None Set rate in which locust shall swarm new user instances. And spawn rate is \" 5 \" users per second And spawn rate is \" 1 \" user per second Arguments : spawn_rate int - number of users per second","title":"step_shapes_spawn_rate"},{"location":"usage/steps/anywhere/#grizzlystepsbackgroundsetup","text":"This module contains step implementations that configures the load test scenario with parameters applicable for all scenarios.","title":"grizzly.steps.background.setup"},{"location":"usage/steps/anywhere/#step_setup_save_statistics","text":"@given ( u 'save statistics to \" {url} \"' ) def step_setup_save_statistics ( context : Context , url : str ) -> None Sets an URL where locust statistics should be sent. It has support for InfluxDB and Azure Application Insights endpoints. For InfluxDB the following format must be used: For Azure Application Insights the following format must be used: influxdb://[<username>:<password>@]<hostname>[:<port>]/<database>?TargetEnviroment=<target environment>[&Testplan=<test plan>] [&TargetEnvironment=<target environment>][&ProfileName=<profile name>][&Description=<description>] insights://?InstrumentationKey=<instrumentation key>&IngestionEndpoint=<ingestion endpoint>[&Testplan=<test plan>] insights://<ingestion endpoint>/?InstrumentationKey=<instrumentation key>[&Testplan=<test plan>] And save statistics to \" influxdb://grizzly:secret-password@influx.example.com/grizzly-statistics \" And save statistics to \" insights://?IngestionEndpoint=https://insights.example.com&Testplan=grizzly-statistics&InstrumentationKey=asdfasdfasdf= \" And save statistics to \" insights://insights.example.com/?Testplan=grizzly-statistics&InstrumentationKey=asdfasdfasdf= \" And save statistics to \" influxdb://$conf::statistics.username:$conf::statistics.password@influx.example.com/$conf::statistics.database \" Arguments : url str - URL for statistics endpoint","title":"step_setup_save_statistics"},{"location":"usage/steps/anywhere/#step_setup_log_level","text":"@given ( u 'log level is \" {log_level} \"' ) def step_setup_log_level ( context : Context , log_level : str ) -> None Configure log level for grizzly . Default value is INFO , by changing to DEBUG there is more information what grizzly is doing behind the curtains. And log level is \" DEBUG \" Arguments : log_level str - allowed values INFO , DEBUG , WARNING och ERROR","title":"step_setup_log_level"},{"location":"usage/steps/anywhere/#step_setup_run_time","text":"@given ( u 'run for maximum \" {timespan} \"' ) def step_setup_run_time ( context : Context , timespan : str ) -> None Configures the time period a headless test should run for. If available test data is infinite, the test will run forever if this step is not used. And run for maximum \" 1h \" Arguments : timespan str - description of how long the test should run for, e.g. 10s, 1h, 40m etc.","title":"step_setup_run_time"},{"location":"usage/steps/anywhere/#step_setup_set_global_context_variable","text":"@given ( u 'set global context variable \" {variable} \" to \" {value} \"' ) def step_setup_set_global_context_variable ( context : Context , variable : str , value : str ) -> None Create a global variable in the context. Depending on which type of user a scenario is configured for, different variables are available. Check grizzly.users documentation for which context variables are available for each user. This step can be used if the feature file has multiple scenarios and all of them have the same context variables. Variable names can contain (one ore more) dot ( . ) or slash ( / ) to indicate that the variable is in a structure. All names will also be converted to lower case. E.g. token.url and token/URL results in: Space in variable names is also allowed and will then be translated to an underscore ( _ ) E.g. Client ID results in client_id . Data type of values will be guessed, if not explicitly specified by the type of variable used ( Atomic* ). E.g. the last two examples above will result in: { ' t oke n ' : { 'url' : '<value>' } } And set global context variable \" token.url \" to \" http://test.nu/api/auth \" And set global context variable \" token/client_id \" to \" aaaa-bbbb-cccc-dddd \" And set global context variable \" token/client secret \" to \" aasdfasdfasdf== \" And set global context variable \" token.resource \" to \" 0000-aaaaaaa-1111-1111-1111 \" And set global context variable \" log_all_requests \" to \" True \" And set global context variable \" validate_certificates \" to \" False \" And set global context variable \" run_id \" to \" 13 \" { 'valida te _cer t i f ica tes ' : False , 'ru n _id' : 13 } Arguments : variable str - variable name, as used in templates value str - variable value","title":"step_setup_set_global_context_variable"},{"location":"usage/steps/anywhere/#grizzlystepsutils","text":"This package contains steps that can be useful during development or troubleshooting of a feature file, but should not be included in a finished, testable, feature.","title":"grizzly.steps.utils"},{"location":"usage/steps/anywhere/#step_utils_fail","text":"@then ( u 'fail' ) def step_utils_fail ( context : Context ) -> None Force a failed scenario. Can be useful when writing a new scenario. Then fail","title":"step_utils_fail"},{"location":"usage/steps/background/setup/","text":"grizzly.steps.background.setup This module contains step implementations that configures the load test scenario with parameters applicable for all scenarios. step_setup_save_statistics @given ( u 'save statistics to \" {url} \"' ) def step_setup_save_statistics ( context : Context , url : str ) -> None Sets an URL where locust statistics should be sent. It has support for InfluxDB and Azure Application Insights endpoints. For InfluxDB the following format must be used: For Azure Application Insights the following format must be used: influxdb://[<username>:<password>@]<hostname>[:<port>]/<database>?TargetEnviroment=<target environment>[&Testplan=<test plan>] [&TargetEnvironment=<target environment>][&ProfileName=<profile name>][&Description=<description>] insights://?InstrumentationKey=<instrumentation key>&IngestionEndpoint=<ingestion endpoint>[&Testplan=<test plan>] insights://<ingestion endpoint>/?InstrumentationKey=<instrumentation key>[&Testplan=<test plan>] And save statistics to \" influxdb://grizzly:secret-password@influx.example.com/grizzly-statistics \" And save statistics to \" insights://?IngestionEndpoint=https://insights.example.com&Testplan=grizzly-statistics&InstrumentationKey=asdfasdfasdf= \" And save statistics to \" insights://insights.example.com/?Testplan=grizzly-statistics&InstrumentationKey=asdfasdfasdf= \" And save statistics to \" influxdb://$conf::statistics.username:$conf::statistics.password@influx.example.com/$conf::statistics.database \" Arguments : url str - URL for statistics endpoint step_setup_log_level @given ( u 'log level is \" {log_level} \"' ) def step_setup_log_level ( context : Context , log_level : str ) -> None Configure log level for grizzly . Default value is INFO , by changing to DEBUG there is more information what grizzly is doing behind the curtains. And log level is \" DEBUG \" Arguments : log_level str - allowed values INFO , DEBUG , WARNING och ERROR step_setup_run_time @given ( u 'run for maximum \" {timespan} \"' ) def step_setup_run_time ( context : Context , timespan : str ) -> None Configures the time period a headless test should run for. If available test data is infinite, the test will run forever if this step is not used. And run for maximum \" 1h \" Arguments : timespan str - description of how long the test should run for, e.g. 10s, 1h, 40m etc. step_setup_set_global_context_variable @given ( u 'set global context variable \" {variable} \" to \" {value} \"' ) def step_setup_set_global_context_variable ( context : Context , variable : str , value : str ) -> None Create a global variable in the context. Depending on which type of user a scenario is configured for, different variables are available. Check grizzly.users documentation for which context variables are available for each user. This step can be used if the feature file has multiple scenarios and all of them have the same context variables. Variable names can contain (one ore more) dot ( . ) or slash ( / ) to indicate that the variable is in a structure. All names will also be converted to lower case. E.g. token.url and token/URL results in: Space in variable names is also allowed and will then be translated to an underscore ( _ ) E.g. Client ID results in client_id . Data type of values will be guessed, if not explicitly specified by the type of variable used ( Atomic* ). E.g. the last two examples above will result in: { ' t oke n ' : { 'url' : '<value>' } } And set global context variable \" token.url \" to \" http://test.nu/api/auth \" And set global context variable \" token/client_id \" to \" aaaa-bbbb-cccc-dddd \" And set global context variable \" token/client secret \" to \" aasdfasdfasdf== \" And set global context variable \" token.resource \" to \" 0000-aaaaaaa-1111-1111-1111 \" And set global context variable \" log_all_requests \" to \" True \" And set global context variable \" validate_certificates \" to \" False \" And set global context variable \" run_id \" to \" 13 \" { 'valida te _cer t i f ica tes ' : False , 'ru n _id' : 13 } Arguments : variable str - variable name, as used in templates value str - variable value","title":"Setup"},{"location":"usage/steps/background/setup/#grizzlystepsbackgroundsetup","text":"This module contains step implementations that configures the load test scenario with parameters applicable for all scenarios.","title":"grizzly.steps.background.setup"},{"location":"usage/steps/background/setup/#step_setup_save_statistics","text":"@given ( u 'save statistics to \" {url} \"' ) def step_setup_save_statistics ( context : Context , url : str ) -> None Sets an URL where locust statistics should be sent. It has support for InfluxDB and Azure Application Insights endpoints. For InfluxDB the following format must be used: For Azure Application Insights the following format must be used: influxdb://[<username>:<password>@]<hostname>[:<port>]/<database>?TargetEnviroment=<target environment>[&Testplan=<test plan>] [&TargetEnvironment=<target environment>][&ProfileName=<profile name>][&Description=<description>] insights://?InstrumentationKey=<instrumentation key>&IngestionEndpoint=<ingestion endpoint>[&Testplan=<test plan>] insights://<ingestion endpoint>/?InstrumentationKey=<instrumentation key>[&Testplan=<test plan>] And save statistics to \" influxdb://grizzly:secret-password@influx.example.com/grizzly-statistics \" And save statistics to \" insights://?IngestionEndpoint=https://insights.example.com&Testplan=grizzly-statistics&InstrumentationKey=asdfasdfasdf= \" And save statistics to \" insights://insights.example.com/?Testplan=grizzly-statistics&InstrumentationKey=asdfasdfasdf= \" And save statistics to \" influxdb://$conf::statistics.username:$conf::statistics.password@influx.example.com/$conf::statistics.database \" Arguments : url str - URL for statistics endpoint","title":"step_setup_save_statistics"},{"location":"usage/steps/background/setup/#step_setup_log_level","text":"@given ( u 'log level is \" {log_level} \"' ) def step_setup_log_level ( context : Context , log_level : str ) -> None Configure log level for grizzly . Default value is INFO , by changing to DEBUG there is more information what grizzly is doing behind the curtains. And log level is \" DEBUG \" Arguments : log_level str - allowed values INFO , DEBUG , WARNING och ERROR","title":"step_setup_log_level"},{"location":"usage/steps/background/setup/#step_setup_run_time","text":"@given ( u 'run for maximum \" {timespan} \"' ) def step_setup_run_time ( context : Context , timespan : str ) -> None Configures the time period a headless test should run for. If available test data is infinite, the test will run forever if this step is not used. And run for maximum \" 1h \" Arguments : timespan str - description of how long the test should run for, e.g. 10s, 1h, 40m etc.","title":"step_setup_run_time"},{"location":"usage/steps/background/setup/#step_setup_set_global_context_variable","text":"@given ( u 'set global context variable \" {variable} \" to \" {value} \"' ) def step_setup_set_global_context_variable ( context : Context , variable : str , value : str ) -> None Create a global variable in the context. Depending on which type of user a scenario is configured for, different variables are available. Check grizzly.users documentation for which context variables are available for each user. This step can be used if the feature file has multiple scenarios and all of them have the same context variables. Variable names can contain (one ore more) dot ( . ) or slash ( / ) to indicate that the variable is in a structure. All names will also be converted to lower case. E.g. token.url and token/URL results in: Space in variable names is also allowed and will then be translated to an underscore ( _ ) E.g. Client ID results in client_id . Data type of values will be guessed, if not explicitly specified by the type of variable used ( Atomic* ). E.g. the last two examples above will result in: { ' t oke n ' : { 'url' : '<value>' } } And set global context variable \" token.url \" to \" http://test.nu/api/auth \" And set global context variable \" token/client_id \" to \" aaaa-bbbb-cccc-dddd \" And set global context variable \" token/client secret \" to \" aasdfasdfasdf== \" And set global context variable \" token.resource \" to \" 0000-aaaaaaa-1111-1111-1111 \" And set global context variable \" log_all_requests \" to \" True \" And set global context variable \" validate_certificates \" to \" False \" And set global context variable \" run_id \" to \" 13 \" { 'valida te _cer t i f ica tes ' : False , 'ru n _id' : 13 } Arguments : variable str - variable name, as used in templates value str - variable value","title":"step_setup_set_global_context_variable"},{"location":"usage/steps/background/shapes/","text":"grizzly.steps.background.shapes This module contains step implementations that describes the actual load all scenarios in a feature will generate. step_shapes_user_count @given ( u '\" {user_count:d} \" {user_number:UserGramaticalNumber}' ) def step_shapes_user_count ( context : Context , user_count : int , user_number : str ) -> None Set number of users that will generate load. Given \" 5 \" users Given \" 1 \" user Given \" $conf::load.user.count \" Arguments : user_count int - Number of users locust should create step_shapes_spawn_rate @given ( u 'spawn rate is \" {spawn_rate:d} \" {user_number:UserGramaticalNumber} per second' ) def step_shapes_spawn_rate ( context : Context , spawn_rate : int , user_number : str ) -> None Set rate in which locust shall swarm new user instances. And spawn rate is \" 5 \" users per second And spawn rate is \" 1 \" user per second Arguments : spawn_rate int - number of users per second","title":"Shapes"},{"location":"usage/steps/background/shapes/#grizzlystepsbackgroundshapes","text":"This module contains step implementations that describes the actual load all scenarios in a feature will generate.","title":"grizzly.steps.background.shapes"},{"location":"usage/steps/background/shapes/#step_shapes_user_count","text":"@given ( u '\" {user_count:d} \" {user_number:UserGramaticalNumber}' ) def step_shapes_user_count ( context : Context , user_count : int , user_number : str ) -> None Set number of users that will generate load. Given \" 5 \" users Given \" 1 \" user Given \" $conf::load.user.count \" Arguments : user_count int - Number of users locust should create","title":"step_shapes_user_count"},{"location":"usage/steps/background/shapes/#step_shapes_spawn_rate","text":"@given ( u 'spawn rate is \" {spawn_rate:d} \" {user_number:UserGramaticalNumber} per second' ) def step_shapes_spawn_rate ( context : Context , spawn_rate : int , user_number : str ) -> None Set rate in which locust shall swarm new user instances. And spawn rate is \" 5 \" users per second And spawn rate is \" 1 \" user per second Arguments : spawn_rate int - number of users per second","title":"step_shapes_spawn_rate"},{"location":"usage/steps/scenario/response/","text":"grizzly.steps.scenario.response This module contains step implementations that handles request responses. step_response_save_matches @then ( u 'save response {target:ResponseTarget} \" {expression} \" that matches \" {match_with} \" in variable \" {variable} \"' ) def step_response_save_matches ( context : Context , target : ResponseTarget , expression : str , match_with : str , variable : str ) -> None Save specified parts of a response, either from meta data (header) or payload (body), in a variable. With this step it is possible to change variable values and as such use values from a response later on in the load test. This step will fail if the specified expression has no match or more than one match. # only token is matched and saved in TOKEN, by using regexp match groups And value of variable \" TOKEN \" is \" none \" Then save response metadata \" $.Authentication \" that matches \" Bearer (.*)$ \" in variabel \" TOKEN \" # the whole value is saved, as long as Authentication starts with \"Bearer\" And value of variable \" HEADER_AUTHENTICATION \" is \" none \" Then save response metadata \" $.Authentication \" that matches \" ^Bearer .*$ \" in variable \" HEADER_AUTHENTICATION \" # only the numerical suffix is saved in the variable And value of variable \" AtomicInteger.measurermentId \" is \" 0 \" Then save response payload \" $.measurement.id \" that matches \" ^cpu([\\\\d]+)$ \" in \" AtomicInteger.measurementId \" # the whole value is saved, as long as the value starts with \"cpu\" And value of variable \" measurementId \" is \" 0 \" Then save response payload \" $.measurement.id \" that matches \" ^cpu[\\\\d]+$ \" in \" measurementId \" # xpath example And set response content type to \" application/xml \" And value of variable \" xmlMeasurementId \" is \" none \" Then save response payload \" //measurement[0]/id/text() \" that matches \" ^cpu[\\\\d]+$ \" in \" xmlMeasurementId \" Arguments : target enum - \"metadata\" or \"payload\", depending on which part of the response should be used expression str - JSON path or XPath expression for finding the property match_with str - static value or a regular expression variable str - name of the already initialized variable to save the value in step_response_save @then ( u 'save response {target:ResponseTarget} \" {expression} \" in variable \" {variable} \"' ) def step_response_save ( context : Context , target : ResponseTarget , expression : str , variable : str ) -> None Save metadata (header) or payload (body) value from a response in a variable. This step is the same as step_response_save_matches if match_with is set to .* . With this step it is possible to change variable values and as such use values from a response later on in the load test. This step will fail if the specified expression has no match or more than one match. Then save response metadata \" $.Authentication \" in variable \" HEADER_AUTHENTICATION \" Then save response payload \" $.Result.ShipmentId \" in variable \" ShipmentId \" Then save response payload \" //measurement[0]/id/text() \" in \" xmlMeasurementId \" Arguments : target enum - \"metadata\" or \"payload\", depending on which part of the response should be used expression str - JSON path or XPath expression for finding the property variable str - name of the already initialized variable to save the value in step_response_validate @when ( u 'response {target:ResponseTarget} \" {expression} \" {condition:Condition} \" {match_with} \" stop user' ) def step_response_validate ( context : Context , target : ResponseTarget , expression : str , condition : bool , match_with : str ) -> None Fails the scenario based on the value of a response meta data (header) or payload (body). When response metadata \" $.['content-type'] \" is not \" .*application/json.* \" stop user When response metadata \" $.['x-test-command'] \" is \" abort \" stop user When response metadata \" $.Authentication \" is not \" Bearer .*$ \" stop user When response payload \" $.measurement.id \" is not \" cpu[0-9]+ \" stop user When response payload \" $.success \" is \" false \" stop user When response payload \" /root/measurement[@id= \"cpu\" ]/success/text() \" is \" 'false' \" stop user Arguments : target enum - \"metadata\" or \"payload\", depending on which part of the response should be used expression str - JSON path or XPath expression for finding the property condition enum - \"is\" or \"is not\" depending on negative or postive matching match_with str - static value or a regular expression step_response_allow_status_codes @then ( u 'allow response status codes \" {status_list} \"' ) def step_response_allow_status_codes ( context : Context , status_list : str ) -> None Set allowed response status codes for the latest defined request in the scenario. By default 200 is the only allowed respoonse status code. By prefixing a code with minus ( - ), it will be removed from the list of allowed response status codes. Then get request with name \" test-get-1 \" from endpoint \" /api/test \" And allow response status \" 200,302 \" Then get request with name \" test-failed-get-2 \" from endpoint \" /api/non-existing \" And allow response status \" -200,404 \" Arguments : status_list str - comma separated list of integers step_response_allow_status_codes_table @then ( u 'allow response status codes' ) def step_response_allow_status_codes_table ( context : Context ) -> None Set allowed response status codes for the latest defined requests based on a data table. Specifies a comma separeated list of allowed return codes for the latest requests in a data table. By default 200 is the only allowed respoonse status code. By prefixing a code with minus ( - ), it will be removed from the list of allowed response status codes. Number of rows in the table specifies which of the latest defined requests the allowed response status codes should map to. The table must have the column header status . Then get request with name \" test-get-1 \" from endpoint \" /api/test \" Then get request with name \" test-get-2 \" from endpoint \" /api/test \" And allow response status | status | | 200, 302 | | 200,404 | Allowed response status codes for test-get-1 is now 200 and 302 , and for test-get-2 is now 200 and 404 . step_response_content_type @then ( u 'set response content type to \"{content_type:ResponseContentType}\"' ) def step_response_content_type ( context : Context , content_type : ResponseContentType ) -> None Set the content type of a response, instead of guessing it. This is applicable when there is a step_response_validate or step_response_save is included in the scenario, and is valid only for the latest defined request. And set response content type to \" json \" And set response content type to \" application/json \" And set response content type to \" xml \" And set response content type to \" application/xml \" And set response content type to \" plain \" And set response content type to \" text/plain \" Arguments : content_type ResponseContentType - expected content type of response","title":"Response"},{"location":"usage/steps/scenario/response/#grizzlystepsscenarioresponse","text":"This module contains step implementations that handles request responses.","title":"grizzly.steps.scenario.response"},{"location":"usage/steps/scenario/response/#step_response_save_matches","text":"@then ( u 'save response {target:ResponseTarget} \" {expression} \" that matches \" {match_with} \" in variable \" {variable} \"' ) def step_response_save_matches ( context : Context , target : ResponseTarget , expression : str , match_with : str , variable : str ) -> None Save specified parts of a response, either from meta data (header) or payload (body), in a variable. With this step it is possible to change variable values and as such use values from a response later on in the load test. This step will fail if the specified expression has no match or more than one match. # only token is matched and saved in TOKEN, by using regexp match groups And value of variable \" TOKEN \" is \" none \" Then save response metadata \" $.Authentication \" that matches \" Bearer (.*)$ \" in variabel \" TOKEN \" # the whole value is saved, as long as Authentication starts with \"Bearer\" And value of variable \" HEADER_AUTHENTICATION \" is \" none \" Then save response metadata \" $.Authentication \" that matches \" ^Bearer .*$ \" in variable \" HEADER_AUTHENTICATION \" # only the numerical suffix is saved in the variable And value of variable \" AtomicInteger.measurermentId \" is \" 0 \" Then save response payload \" $.measurement.id \" that matches \" ^cpu([\\\\d]+)$ \" in \" AtomicInteger.measurementId \" # the whole value is saved, as long as the value starts with \"cpu\" And value of variable \" measurementId \" is \" 0 \" Then save response payload \" $.measurement.id \" that matches \" ^cpu[\\\\d]+$ \" in \" measurementId \" # xpath example And set response content type to \" application/xml \" And value of variable \" xmlMeasurementId \" is \" none \" Then save response payload \" //measurement[0]/id/text() \" that matches \" ^cpu[\\\\d]+$ \" in \" xmlMeasurementId \" Arguments : target enum - \"metadata\" or \"payload\", depending on which part of the response should be used expression str - JSON path or XPath expression for finding the property match_with str - static value or a regular expression variable str - name of the already initialized variable to save the value in","title":"step_response_save_matches"},{"location":"usage/steps/scenario/response/#step_response_save","text":"@then ( u 'save response {target:ResponseTarget} \" {expression} \" in variable \" {variable} \"' ) def step_response_save ( context : Context , target : ResponseTarget , expression : str , variable : str ) -> None Save metadata (header) or payload (body) value from a response in a variable. This step is the same as step_response_save_matches if match_with is set to .* . With this step it is possible to change variable values and as such use values from a response later on in the load test. This step will fail if the specified expression has no match or more than one match. Then save response metadata \" $.Authentication \" in variable \" HEADER_AUTHENTICATION \" Then save response payload \" $.Result.ShipmentId \" in variable \" ShipmentId \" Then save response payload \" //measurement[0]/id/text() \" in \" xmlMeasurementId \" Arguments : target enum - \"metadata\" or \"payload\", depending on which part of the response should be used expression str - JSON path or XPath expression for finding the property variable str - name of the already initialized variable to save the value in","title":"step_response_save"},{"location":"usage/steps/scenario/response/#step_response_validate","text":"@when ( u 'response {target:ResponseTarget} \" {expression} \" {condition:Condition} \" {match_with} \" stop user' ) def step_response_validate ( context : Context , target : ResponseTarget , expression : str , condition : bool , match_with : str ) -> None Fails the scenario based on the value of a response meta data (header) or payload (body). When response metadata \" $.['content-type'] \" is not \" .*application/json.* \" stop user When response metadata \" $.['x-test-command'] \" is \" abort \" stop user When response metadata \" $.Authentication \" is not \" Bearer .*$ \" stop user When response payload \" $.measurement.id \" is not \" cpu[0-9]+ \" stop user When response payload \" $.success \" is \" false \" stop user When response payload \" /root/measurement[@id= \"cpu\" ]/success/text() \" is \" 'false' \" stop user Arguments : target enum - \"metadata\" or \"payload\", depending on which part of the response should be used expression str - JSON path or XPath expression for finding the property condition enum - \"is\" or \"is not\" depending on negative or postive matching match_with str - static value or a regular expression","title":"step_response_validate"},{"location":"usage/steps/scenario/response/#step_response_allow_status_codes","text":"@then ( u 'allow response status codes \" {status_list} \"' ) def step_response_allow_status_codes ( context : Context , status_list : str ) -> None Set allowed response status codes for the latest defined request in the scenario. By default 200 is the only allowed respoonse status code. By prefixing a code with minus ( - ), it will be removed from the list of allowed response status codes. Then get request with name \" test-get-1 \" from endpoint \" /api/test \" And allow response status \" 200,302 \" Then get request with name \" test-failed-get-2 \" from endpoint \" /api/non-existing \" And allow response status \" -200,404 \" Arguments : status_list str - comma separated list of integers","title":"step_response_allow_status_codes"},{"location":"usage/steps/scenario/response/#step_response_allow_status_codes_table","text":"@then ( u 'allow response status codes' ) def step_response_allow_status_codes_table ( context : Context ) -> None Set allowed response status codes for the latest defined requests based on a data table. Specifies a comma separeated list of allowed return codes for the latest requests in a data table. By default 200 is the only allowed respoonse status code. By prefixing a code with minus ( - ), it will be removed from the list of allowed response status codes. Number of rows in the table specifies which of the latest defined requests the allowed response status codes should map to. The table must have the column header status . Then get request with name \" test-get-1 \" from endpoint \" /api/test \" Then get request with name \" test-get-2 \" from endpoint \" /api/test \" And allow response status | status | | 200, 302 | | 200,404 | Allowed response status codes for test-get-1 is now 200 and 302 , and for test-get-2 is now 200 and 404 .","title":"step_response_allow_status_codes_table"},{"location":"usage/steps/scenario/response/#step_response_content_type","text":"@then ( u 'set response content type to \"{content_type:ResponseContentType}\"' ) def step_response_content_type ( context : Context , content_type : ResponseContentType ) -> None Set the content type of a response, instead of guessing it. This is applicable when there is a step_response_validate or step_response_save is included in the scenario, and is valid only for the latest defined request. And set response content type to \" json \" And set response content type to \" application/json \" And set response content type to \" xml \" And set response content type to \" application/xml \" And set response content type to \" plain \" And set response content type to \" text/plain \" Arguments : content_type ResponseContentType - expected content type of response","title":"step_response_content_type"},{"location":"usage/steps/scenario/results/","text":"grizzly.steps.scenario.results This module contains step implementations that validates the response results for all requests in a scenario. step_results_fail_ratio @when ( u 'fail ratio is greater than \" {fail_ratio:d} \" % f ail scenario' ) def step_results_fail_ratio ( context : Context , fail_ratio : int ) -> None Set how many percentages of requests that are allowed to fail before the whole scenario will be set as failed. This step cannot be used in combination with step_setup_enable_stop_on_failure . Default behavior is not to validate the result for a scenario based on failed requests. When fail ratio is greater than \" 8 \"% fail scenario Arguments : fail_ratio int - percentage of requests that are allowed to fail step_results_avg_response_time @when ( u 'average response time is greater than \" {avg_response_time:d} \" milliseconds fail scenario' ) def step_results_avg_response_time ( context : Context , avg_response_time : int ) -> None Set the average response time (milliseconds) that all requests in a scenario must be below for it to pass. Default behavior is not to validate the result for a scenario based on average response time. When average response time is greater than \" 200 \" milliseconds fail scenario Arguments : avg_response_time int - allowed average response time in milliseconds step_results_response_time_percentile @when ( u 'response time percentile \" {percentile:d} \" % i s greater than \" {response_time:d} \" milliseconds fail scenario' ) def step_results_response_time_percentile ( context : Context , percentile : float , response_time : int ) -> None Set the response time that a specified percentile of the requests needs to be below for the scenario to pass. Default behavior is not to validate the result for a scenario based on percetile response times. When response time percentile \" 95 \"% is greater than \" 200 \" milliseconds fail scenario Arguments : percentile int - percentile to validate (1-100) response_time int - response time in milliseconds","title":"Results"},{"location":"usage/steps/scenario/results/#grizzlystepsscenarioresults","text":"This module contains step implementations that validates the response results for all requests in a scenario.","title":"grizzly.steps.scenario.results"},{"location":"usage/steps/scenario/results/#step_results_fail_ratio","text":"@when ( u 'fail ratio is greater than \" {fail_ratio:d} \" % f ail scenario' ) def step_results_fail_ratio ( context : Context , fail_ratio : int ) -> None Set how many percentages of requests that are allowed to fail before the whole scenario will be set as failed. This step cannot be used in combination with step_setup_enable_stop_on_failure . Default behavior is not to validate the result for a scenario based on failed requests. When fail ratio is greater than \" 8 \"% fail scenario Arguments : fail_ratio int - percentage of requests that are allowed to fail","title":"step_results_fail_ratio"},{"location":"usage/steps/scenario/results/#step_results_avg_response_time","text":"@when ( u 'average response time is greater than \" {avg_response_time:d} \" milliseconds fail scenario' ) def step_results_avg_response_time ( context : Context , avg_response_time : int ) -> None Set the average response time (milliseconds) that all requests in a scenario must be below for it to pass. Default behavior is not to validate the result for a scenario based on average response time. When average response time is greater than \" 200 \" milliseconds fail scenario Arguments : avg_response_time int - allowed average response time in milliseconds","title":"step_results_avg_response_time"},{"location":"usage/steps/scenario/results/#step_results_response_time_percentile","text":"@when ( u 'response time percentile \" {percentile:d} \" % i s greater than \" {response_time:d} \" milliseconds fail scenario' ) def step_results_response_time_percentile ( context : Context , percentile : float , response_time : int ) -> None Set the response time that a specified percentile of the requests needs to be below for the scenario to pass. Default behavior is not to validate the result for a scenario based on percetile response times. When response time percentile \" 95 \"% is greater than \" 200 \" milliseconds fail scenario Arguments : percentile int - percentile to validate (1-100) response_time int - response time in milliseconds","title":"step_results_response_time_percentile"},{"location":"usage/steps/scenario/setup/","text":"grizzly.steps.scenario.setup This module contains step implementations that setup the load test scenario with parameters that is going to be used in the scenario they are defined in. step_setup_set_context_variable @given ( u 'set context variable \" {variable} \" to \" {value} \"' ) def step_setup_set_context_variable ( context : Context , variable : str , value : str ) -> None Set a variable in the scenario context. Variable name can contain (one or more) dot ( . ) or slash ( / ) to indicate that the variable has a nested structure. E.g. token.url and token/url results in: It is also possible to have spaces in a variable name, they will then be replaced with underscore ( _ ), and name will be converted to lowercase. E.g. Client ID results in client_id { ' t oke n ' : { 'url' : '<value>' } } And set context variable \" token.url \" to \" https://example.com/api/auth \" And set context variable \" token/client_id \" to \" aaaa-bbbb-cccc-dddd \" And set context variable \" token/client secret \" to \" aasdfasdfasdf== \" And set context variable \" token.resource \" to \" 0000-aaaaaaa-1111-1111-1111 \" And set context variable \" log_all_requests \" to \" True \" And set context variable \" validate_certificates \" to \" False \" Arguments : variable str - name, can contain . and / value str - value, data type will be guessed and casted step_setup_iterations @given ( u 'repeat for \" {value} \" {iteration_number:IterationGramaticalNumber}' ) def step_setup_iterations ( context : Context , value : str , iteration_number : str ) -> None Set how many iterations of the requests in the scenario should execute. Default value is 1 . A value of 0 means to run until all test data is consumed, or that the (optional) specified runtime for the scenario is reached. And repeat for \" 10 \" iterations And repeat for \" 1 \" iteration And value for variable \" leveranser \" is \" 100 \" And repeat for \" {{ leveranser * 0.25 }} \" iterations Arguments : iterations int - number of iterations of the scenario step_setup_wait_time @given ( u 'wait time inbetween requests is random between \" {minimum:f} \" and \" {maximum:f} \" seconds' ) def step_setup_wait_time ( context : Context , minimum : float , maximum : float ) -> None Set how long (seconds) locust should wait between tasks. Default value is 1.0 seconds. Set wait_min = wait_max if the wait shouldn't be random in the specified interval. And wait time inbetween requests is random between \" 0.3 \" and \" 0.5 \" seconds Arguments : wait_min float - minimum wait time wait_max float - maximum wait time step_setup_variable_value @given ( u 'value for variable \" {name} \" is \" {value} \"' ) def step_setup_variable_value ( context : Context , name : str , value : str ) -> None Initialize a variable. Use this step to initialize a variable that should have the same [start] value for every run of the scenario. Data type for the value of the variable is based on the type of variable. If the variable is an \" Atomic* \"-variable then the value needs to match the format and type that the variable has implemented. If it is a non \" Atomic* \"-variable grizzly will try to guess the data type. E.g.: * \"10\" becomes int * \"1.0\" becomes float * \"True\" becomes bool * everything else becomes str It is possible to set the value of a variable based on another variable, which can be usable if you have a variable in multiple scenarios which all should have the same initial value. And value for variable \" HelloWorld \" is \" default \" Feature: Background: And ask for value of variable \" messageID \" Scenario: And value for variable \" AtomicIntegerIncrementer.mid1 \" is \" {{ messageID }} \" Arguments : name str - variable name value Any - initial value step_setup_set_variable_alias @given ( u 'set alias \" {alias} \" for variable \" {variable} \"' ) def step_setup_set_variable_alias ( context : Context , alias : str , variable : str ) -> None Create an alias for a variable that points to another structure in the context. This is useful if you have test data that somehow should change the behavior for a user, e.g. username and password. Assumed that the file users.csv contains the columns username and password ; without the alias step it would look like the following structure in the context: With the alias step it will be transformed to this: Variables in payload templates are not allowed to have an alias. And set variable \" AtomicCsvRow.users \" to \" users.csv | repeat=True \" And set alias \" auth.user.username \" for variable \" AtomicCsvRow.users.username \" And set alias \" auth.user.password \" for variable \" AtomicCsvRow.users.password \" { \"variables\" : { \"AtomicCsvRow\" : { \"users\" : { \"username\" : \"username\" , \"password\" : \"password\" } } } } { \"auth\" : { \"user\" : { \"username\" : \"username\" , \"password\" : \"password\" } } } Arguments : alias str - which node in the context that should get the value of variable variable str - an already initialized variable that should be renamed step_setup_log_all_requests @given ( u 'log all requests' ) def step_setup_log_all_requests ( context : Context ) -> None Set if all requests should be logged to a file. By default only failed requests (and responses) will be logged. And log all requests step_setup_enable_stop_on_failure @given ( u 'stop on first failure' ) def step_setup_enable_stop_on_failure ( context : Context ) -> None Stop a scenario at first failed request. Default behavior is to continue the scenario if a request fails. And stop on first failure","title":"Setup"},{"location":"usage/steps/scenario/setup/#grizzlystepsscenariosetup","text":"This module contains step implementations that setup the load test scenario with parameters that is going to be used in the scenario they are defined in.","title":"grizzly.steps.scenario.setup"},{"location":"usage/steps/scenario/setup/#step_setup_set_context_variable","text":"@given ( u 'set context variable \" {variable} \" to \" {value} \"' ) def step_setup_set_context_variable ( context : Context , variable : str , value : str ) -> None Set a variable in the scenario context. Variable name can contain (one or more) dot ( . ) or slash ( / ) to indicate that the variable has a nested structure. E.g. token.url and token/url results in: It is also possible to have spaces in a variable name, they will then be replaced with underscore ( _ ), and name will be converted to lowercase. E.g. Client ID results in client_id { ' t oke n ' : { 'url' : '<value>' } } And set context variable \" token.url \" to \" https://example.com/api/auth \" And set context variable \" token/client_id \" to \" aaaa-bbbb-cccc-dddd \" And set context variable \" token/client secret \" to \" aasdfasdfasdf== \" And set context variable \" token.resource \" to \" 0000-aaaaaaa-1111-1111-1111 \" And set context variable \" log_all_requests \" to \" True \" And set context variable \" validate_certificates \" to \" False \" Arguments : variable str - name, can contain . and / value str - value, data type will be guessed and casted","title":"step_setup_set_context_variable"},{"location":"usage/steps/scenario/setup/#step_setup_iterations","text":"@given ( u 'repeat for \" {value} \" {iteration_number:IterationGramaticalNumber}' ) def step_setup_iterations ( context : Context , value : str , iteration_number : str ) -> None Set how many iterations of the requests in the scenario should execute. Default value is 1 . A value of 0 means to run until all test data is consumed, or that the (optional) specified runtime for the scenario is reached. And repeat for \" 10 \" iterations And repeat for \" 1 \" iteration And value for variable \" leveranser \" is \" 100 \" And repeat for \" {{ leveranser * 0.25 }} \" iterations Arguments : iterations int - number of iterations of the scenario","title":"step_setup_iterations"},{"location":"usage/steps/scenario/setup/#step_setup_wait_time","text":"@given ( u 'wait time inbetween requests is random between \" {minimum:f} \" and \" {maximum:f} \" seconds' ) def step_setup_wait_time ( context : Context , minimum : float , maximum : float ) -> None Set how long (seconds) locust should wait between tasks. Default value is 1.0 seconds. Set wait_min = wait_max if the wait shouldn't be random in the specified interval. And wait time inbetween requests is random between \" 0.3 \" and \" 0.5 \" seconds Arguments : wait_min float - minimum wait time wait_max float - maximum wait time","title":"step_setup_wait_time"},{"location":"usage/steps/scenario/setup/#step_setup_variable_value","text":"@given ( u 'value for variable \" {name} \" is \" {value} \"' ) def step_setup_variable_value ( context : Context , name : str , value : str ) -> None Initialize a variable. Use this step to initialize a variable that should have the same [start] value for every run of the scenario. Data type for the value of the variable is based on the type of variable. If the variable is an \" Atomic* \"-variable then the value needs to match the format and type that the variable has implemented. If it is a non \" Atomic* \"-variable grizzly will try to guess the data type. E.g.: * \"10\" becomes int * \"1.0\" becomes float * \"True\" becomes bool * everything else becomes str It is possible to set the value of a variable based on another variable, which can be usable if you have a variable in multiple scenarios which all should have the same initial value. And value for variable \" HelloWorld \" is \" default \" Feature: Background: And ask for value of variable \" messageID \" Scenario: And value for variable \" AtomicIntegerIncrementer.mid1 \" is \" {{ messageID }} \" Arguments : name str - variable name value Any - initial value","title":"step_setup_variable_value"},{"location":"usage/steps/scenario/setup/#step_setup_set_variable_alias","text":"@given ( u 'set alias \" {alias} \" for variable \" {variable} \"' ) def step_setup_set_variable_alias ( context : Context , alias : str , variable : str ) -> None Create an alias for a variable that points to another structure in the context. This is useful if you have test data that somehow should change the behavior for a user, e.g. username and password. Assumed that the file users.csv contains the columns username and password ; without the alias step it would look like the following structure in the context: With the alias step it will be transformed to this: Variables in payload templates are not allowed to have an alias. And set variable \" AtomicCsvRow.users \" to \" users.csv | repeat=True \" And set alias \" auth.user.username \" for variable \" AtomicCsvRow.users.username \" And set alias \" auth.user.password \" for variable \" AtomicCsvRow.users.password \" { \"variables\" : { \"AtomicCsvRow\" : { \"users\" : { \"username\" : \"username\" , \"password\" : \"password\" } } } } { \"auth\" : { \"user\" : { \"username\" : \"username\" , \"password\" : \"password\" } } } Arguments : alias str - which node in the context that should get the value of variable variable str - an already initialized variable that should be renamed","title":"step_setup_set_variable_alias"},{"location":"usage/steps/scenario/setup/#step_setup_log_all_requests","text":"@given ( u 'log all requests' ) def step_setup_log_all_requests ( context : Context ) -> None Set if all requests should be logged to a file. By default only failed requests (and responses) will be logged. And log all requests","title":"step_setup_log_all_requests"},{"location":"usage/steps/scenario/setup/#step_setup_enable_stop_on_failure","text":"@given ( u 'stop on first failure' ) def step_setup_enable_stop_on_failure ( context : Context ) -> None Stop a scenario at first failed request. Default behavior is to continue the scenario if a request fails. And stop on first failure","title":"step_setup_enable_stop_on_failure"},{"location":"usage/steps/scenario/tasks/","text":"grizzly.steps.scenario.tasks This module contains step implementations that describes requests sent by user_class_name targeting host . step_task_request_text_with_name_to_endpoint @then ( u '{method:Method} request with name \" {name} \" {direction:Direction} endpoint \" {endpoint} \"' ) def step_task_request_text_with_name_to_endpoint ( context : Context , method : RequestMethod , name : str , direction : RequestDirection , endpoint : str ) -> None Creates a named request to an endpoint on host , where optional payload is defined directly in the feature file. If method in the expression is get or receive ; the direction must be from . If method in the expression is post , pust , or send ; the direction must be to , and payload defined in the feature file. Then post request with name \" test-post \" to endpoint \" /api/test \" \"\"\" { \"test\": \"hello world\" } \"\"\" Then put request with name \" test-post \" to endpoint \" /api/test \" \"\"\" { \"test\": \"hello world\" } \"\"\" Then get request with name \" test-get \" from endpoint \" /api/test \" Then send request with name \" test-send \" to endpoint \" receive-queue \" \"\"\" { \"value\": \"do something\" } \"\"\" Then receive request with name \" test-receive \" from endpoint \" receive-queue \" Arguments : method RequestMethod - type of request name str - name of the requests in logs, can contain variables direction RequestDirection - one of to or from depending on the value of method endpoint str - URI relative to host in the scenario, can contain variables and in certain cases user_class_name specific parameters step_task_request_file_with_name_endpoint @then ( u '{method:Method} request \" {source} \" with name \" {name} \" to endpoint \" {endpoint} \"' ) def step_task_request_file_with_name_endpoint ( context : Context , method : RequestMethod , source : str , name : str , endpoint : str ) -> None Creates a named request to an endpoint on host , where the payload is defined in a template file. Then send request \" test/request.j2.json \" with name \" test-send \" to endpoint \" receive-queue \" Then post request \" test/request.j2.json \" with name \" test-post \" to endpoint \" /api/test \" Then put request \" test/request.j2.json \" with name \" test-put \" to endpoint \" /api/test \" Arguments : method RequestMethod - type of request source str - path to a template file relative to the directory requests/ , which must exist in the directory the feature file is located name str - name of the requests in logs, can contain variables endpoint str - URI relative to host in the scenario, can contain variables and in certain cases user_class_name specific parameters step_task_request_file_with_name @then ( u '{method:Method} request \" {source} \" with name \" {name} \"' ) def step_task_request_file_with_name ( context : Context , method : RequestMethod , source : str , name : str ) -> None Creates a named request to the same endpoint as previous request, where the payload is defined in a template file. Then post request \" test/request1.j2.json \" with name \" test-post1 \" to endpoint \" /api/test \" Then post request \" test/request2.j2.json \" with name \" test-post2 \" # same as Then post request \" test/request1.j2.json \" with name \" test-post1 \" to endpoint \" /api/test \" Then post request \" test/request2.j2.json \" with name \" test-post2 \" to endpoint \" /api/test \" Arguments : method RequestMethod - type of request source str - path to a template file relative to the directory requests/ , which must exist in the directory the feature file is located name str - name of the requests in logs, can contain variables step_task_request_text_with_name @then ( u '{method:Method} request with name \" {name} \"' ) def step_task_request_text_with_name ( context : Context , method : RequestMethod , name : str ) -> None Creates a named request to the same endpoint as previous request, where optional payload is defined directly in the feature file. If method in the expression is post , put or send the payload in the request must be defined directly in the feature file after the step. This step is useful if method and endpoint are the same as previous request, but the payload should be different. Then post request with name \" test-post-1 \" to endpoint \" /api/test \" \"\"\" { \"value\": \"hello world!\" } \"\"\" Then post request with name \" test-post-2 \" \"\"\" { \"value\": \"i have good news!\" } \"\"\" # same as Then post request with name \" test-post-1 \" to endpoint \" /api/test \" \"\"\" { \"value\": \"hello world!\" } \"\"\" Then post request with name \" test-post-2 \" to endpoint \" /api/test \" \"\"\" { \"value\": \"i have good news!\" } \"\"\" Then get request with name \" test-get-1 \" from endpoint \" /api/test \" Then get request with name \" test-get-2 \" # same as Then get request with name \" test-get-1 \" from endpoint \" /api/test \" Then get request with name \" test-get-2 \" from endpoint \" /api/test \" Arguments : method RequestMethod - type of request name str - name of the requests in logs, can contain variables step_task_wait_seconds @then ( u 'wait for \" {wait_time:f} \" seconds' ) def step_task_wait_seconds ( context : Context , wait_time : float ) -> None Create an explicit wait (task) in the scenario. The scenario will wait the time specified (seconds) on top of what has been defined in step_setup_wait_time . Above combinations of steps will result in a wait time between 3 and 4 seconds for the first request that is defined after the And wait for... -step. And wait time inbetween requests is random between \" 1.5 \" and \" 2.5 \" seconds ... And wait for \" 1.5 \" seconds Arguments : wait_time float - wait time in seconds step_task_print_message @then ( u 'print message \" {message} \"' ) def step_task_print_message ( context : Context , message : str ) -> None Print a message in the scenario. Useful for visualizing values of variables. The message can be a jinja template, and any variables will be rendered at the time the task executes. And print message \" context_variable='{{ context_variable }}' Arguments : message str - message to print","title":"Tasks"},{"location":"usage/steps/scenario/tasks/#grizzlystepsscenariotasks","text":"This module contains step implementations that describes requests sent by user_class_name targeting host .","title":"grizzly.steps.scenario.tasks"},{"location":"usage/steps/scenario/tasks/#step_task_request_text_with_name_to_endpoint","text":"@then ( u '{method:Method} request with name \" {name} \" {direction:Direction} endpoint \" {endpoint} \"' ) def step_task_request_text_with_name_to_endpoint ( context : Context , method : RequestMethod , name : str , direction : RequestDirection , endpoint : str ) -> None Creates a named request to an endpoint on host , where optional payload is defined directly in the feature file. If method in the expression is get or receive ; the direction must be from . If method in the expression is post , pust , or send ; the direction must be to , and payload defined in the feature file. Then post request with name \" test-post \" to endpoint \" /api/test \" \"\"\" { \"test\": \"hello world\" } \"\"\" Then put request with name \" test-post \" to endpoint \" /api/test \" \"\"\" { \"test\": \"hello world\" } \"\"\" Then get request with name \" test-get \" from endpoint \" /api/test \" Then send request with name \" test-send \" to endpoint \" receive-queue \" \"\"\" { \"value\": \"do something\" } \"\"\" Then receive request with name \" test-receive \" from endpoint \" receive-queue \" Arguments : method RequestMethod - type of request name str - name of the requests in logs, can contain variables direction RequestDirection - one of to or from depending on the value of method endpoint str - URI relative to host in the scenario, can contain variables and in certain cases user_class_name specific parameters","title":"step_task_request_text_with_name_to_endpoint"},{"location":"usage/steps/scenario/tasks/#step_task_request_file_with_name_endpoint","text":"@then ( u '{method:Method} request \" {source} \" with name \" {name} \" to endpoint \" {endpoint} \"' ) def step_task_request_file_with_name_endpoint ( context : Context , method : RequestMethod , source : str , name : str , endpoint : str ) -> None Creates a named request to an endpoint on host , where the payload is defined in a template file. Then send request \" test/request.j2.json \" with name \" test-send \" to endpoint \" receive-queue \" Then post request \" test/request.j2.json \" with name \" test-post \" to endpoint \" /api/test \" Then put request \" test/request.j2.json \" with name \" test-put \" to endpoint \" /api/test \" Arguments : method RequestMethod - type of request source str - path to a template file relative to the directory requests/ , which must exist in the directory the feature file is located name str - name of the requests in logs, can contain variables endpoint str - URI relative to host in the scenario, can contain variables and in certain cases user_class_name specific parameters","title":"step_task_request_file_with_name_endpoint"},{"location":"usage/steps/scenario/tasks/#step_task_request_file_with_name","text":"@then ( u '{method:Method} request \" {source} \" with name \" {name} \"' ) def step_task_request_file_with_name ( context : Context , method : RequestMethod , source : str , name : str ) -> None Creates a named request to the same endpoint as previous request, where the payload is defined in a template file. Then post request \" test/request1.j2.json \" with name \" test-post1 \" to endpoint \" /api/test \" Then post request \" test/request2.j2.json \" with name \" test-post2 \" # same as Then post request \" test/request1.j2.json \" with name \" test-post1 \" to endpoint \" /api/test \" Then post request \" test/request2.j2.json \" with name \" test-post2 \" to endpoint \" /api/test \" Arguments : method RequestMethod - type of request source str - path to a template file relative to the directory requests/ , which must exist in the directory the feature file is located name str - name of the requests in logs, can contain variables","title":"step_task_request_file_with_name"},{"location":"usage/steps/scenario/tasks/#step_task_request_text_with_name","text":"@then ( u '{method:Method} request with name \" {name} \"' ) def step_task_request_text_with_name ( context : Context , method : RequestMethod , name : str ) -> None Creates a named request to the same endpoint as previous request, where optional payload is defined directly in the feature file. If method in the expression is post , put or send the payload in the request must be defined directly in the feature file after the step. This step is useful if method and endpoint are the same as previous request, but the payload should be different. Then post request with name \" test-post-1 \" to endpoint \" /api/test \" \"\"\" { \"value\": \"hello world!\" } \"\"\" Then post request with name \" test-post-2 \" \"\"\" { \"value\": \"i have good news!\" } \"\"\" # same as Then post request with name \" test-post-1 \" to endpoint \" /api/test \" \"\"\" { \"value\": \"hello world!\" } \"\"\" Then post request with name \" test-post-2 \" to endpoint \" /api/test \" \"\"\" { \"value\": \"i have good news!\" } \"\"\" Then get request with name \" test-get-1 \" from endpoint \" /api/test \" Then get request with name \" test-get-2 \" # same as Then get request with name \" test-get-1 \" from endpoint \" /api/test \" Then get request with name \" test-get-2 \" from endpoint \" /api/test \" Arguments : method RequestMethod - type of request name str - name of the requests in logs, can contain variables","title":"step_task_request_text_with_name"},{"location":"usage/steps/scenario/tasks/#step_task_wait_seconds","text":"@then ( u 'wait for \" {wait_time:f} \" seconds' ) def step_task_wait_seconds ( context : Context , wait_time : float ) -> None Create an explicit wait (task) in the scenario. The scenario will wait the time specified (seconds) on top of what has been defined in step_setup_wait_time . Above combinations of steps will result in a wait time between 3 and 4 seconds for the first request that is defined after the And wait for... -step. And wait time inbetween requests is random between \" 1.5 \" and \" 2.5 \" seconds ... And wait for \" 1.5 \" seconds Arguments : wait_time float - wait time in seconds","title":"step_task_wait_seconds"},{"location":"usage/steps/scenario/tasks/#step_task_print_message","text":"@then ( u 'print message \" {message} \"' ) def step_task_print_message ( context : Context , message : str ) -> None Print a message in the scenario. Useful for visualizing values of variables. The message can be a jinja template, and any variables will be rendered at the time the task executes. And print message \" context_variable='{{ context_variable }}' Arguments : message str - message to print","title":"step_task_print_message"},{"location":"usage/steps/scenario/user/","text":"grizzly.steps.scenario.user This module contains step implementations that describes a user. step_user_type @given ( u 'a user of type \" {user_class_name} \" load testing \" {host} \"' ) def step_user_type ( context : Context , user_class_name : str , host : str ) -> None Set which type of user the scenario should use and which host is the target. Given a user of type \" RestApi \" load testing \" http://api.google.com \" Given a user of type \" MessageQueue \" load testing \" mq://mqm:secret@mq.example.com/?QueueManager=QMGR01&Channel=Channel01 \" Given a user of type \" ServiceBus \" load testing \" sb://sb.example.com/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=abc123def456ghi789= \" Given a user of type \" BlobStorage \" load testing \" DefaultEndpointsProtocol=https;EndpointSuffix=core.windows.net;AccountName=examplestorage;AccountKey=xxxyyyyzzz== \" Arguments : user_class_name str - name of an implementation in grizzly.users , with or without User host str - an URL for the target host, format depends on which user_class_name (see grizzly.users )","title":"User"},{"location":"usage/steps/scenario/user/#grizzlystepsscenariouser","text":"This module contains step implementations that describes a user.","title":"grizzly.steps.scenario.user"},{"location":"usage/steps/scenario/user/#step_user_type","text":"@given ( u 'a user of type \" {user_class_name} \" load testing \" {host} \"' ) def step_user_type ( context : Context , user_class_name : str , host : str ) -> None Set which type of user the scenario should use and which host is the target. Given a user of type \" RestApi \" load testing \" http://api.google.com \" Given a user of type \" MessageQueue \" load testing \" mq://mqm:secret@mq.example.com/?QueueManager=QMGR01&Channel=Channel01 \" Given a user of type \" ServiceBus \" load testing \" sb://sb.example.com/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=abc123def456ghi789= \" Given a user of type \" BlobStorage \" load testing \" DefaultEndpointsProtocol=https;EndpointSuffix=core.windows.net;AccountName=examplestorage;AccountKey=xxxyyyyzzz== \" Arguments : user_class_name str - name of an implementation in grizzly.users , with or without User host str - an URL for the target host, format depends on which user_class_name (see grizzly.users )","title":"step_user_type"},{"location":"usage/variables/environment-configuration/","text":"Environment configuration It is possible to make the feature file environment agnostic by providing a yaml file containing a dictionary with a root node named configuration . The environment configuration file can also be used to store credentials and other sensitive information that should not be under version control. Internally grizzly will check if the environment variable GRIZZLY_CONFIGURATION_FILE is set and contains a valid environment configuration file. When using grizzly-cli you specify the file with -c/--configuration which then will be set as a value for GRIZZLY_CONFIGURATION_FILE . Format An example environment configuration file: configuration : frontend : host : https://www.example.com backend : host : https://backend.example.com auth : user : username : bob password : Who-the-f-is-alice The only rule for any nodes under configuration is that it must be a dictionary, since the path to a value will be flattened. Usage In a feature file the dictionary can then be used by prefixing the path of a node under configuration with $conf:: . Example: Feature: application test Background: common configuration Given \" 1 \" users And spawn rate is \" 1 \" user per second And stop on first failure Scenario: frontend Given a user of type \" RestApi \" load testing \" $conf::frontend.host \" ... Scenario: backend Given a user of type \" RestApi \" load testing \" $conf::backend.host \" And set context variable \" auth.user.username \" to \" $conf::backend.auth.user.username \" And set context variable \" auth.user.password \" to \" $conf::backend.auth.user.password \" This feature can now be run against a different environment just by creating a new environment configuration file with different values.","title":"Environment configuration"},{"location":"usage/variables/environment-configuration/#environment-configuration","text":"It is possible to make the feature file environment agnostic by providing a yaml file containing a dictionary with a root node named configuration . The environment configuration file can also be used to store credentials and other sensitive information that should not be under version control. Internally grizzly will check if the environment variable GRIZZLY_CONFIGURATION_FILE is set and contains a valid environment configuration file. When using grizzly-cli you specify the file with -c/--configuration which then will be set as a value for GRIZZLY_CONFIGURATION_FILE .","title":"Environment configuration"},{"location":"usage/variables/environment-configuration/#format","text":"An example environment configuration file: configuration : frontend : host : https://www.example.com backend : host : https://backend.example.com auth : user : username : bob password : Who-the-f-is-alice The only rule for any nodes under configuration is that it must be a dictionary, since the path to a value will be flattened.","title":"Format"},{"location":"usage/variables/environment-configuration/#usage","text":"In a feature file the dictionary can then be used by prefixing the path of a node under configuration with $conf:: . Example: Feature: application test Background: common configuration Given \" 1 \" users And spawn rate is \" 1 \" user per second And stop on first failure Scenario: frontend Given a user of type \" RestApi \" load testing \" $conf::frontend.host \" ... Scenario: backend Given a user of type \" RestApi \" load testing \" $conf::backend.host \" And set context variable \" auth.user.username \" to \" $conf::backend.auth.user.username \" And set context variable \" auth.user.password \" to \" $conf::backend.auth.user.password \" This feature can now be run against a different environment just by creating a new environment configuration file with different values.","title":"Usage"},{"location":"usage/variables/templating/","text":"Templating grizzly has support for templating in both step expression variables (most) and request payload, with the templating backend Jinja2 . Request payload Request payload is treated as complete Jinja2 templates and has full support for any Jinja2 features. Request payload files must be stored in ./features/requests and are referenced in a feature file as a relative path to that directory. . \u2514\u2500\u2500 features \u251c\u2500\u2500 load-test.feature \u2514\u2500\u2500 requests \u2514\u2500\u2500 load-test \u2514\u2500\u2500 request.j2.json Consider that load-test.feature contains the following steps: Feature: templating example Background: common settings for all scenarios Given \" 1 \" user And spawn rate is \" 1 \" user per second And stop on first failure Scenario: example Given a user of type \" RestApi \" load testing \" https://localhost \" And repeat for \" 3 \" iterations And value for variable \" AtomicIntegerIncrementer.items \" is \" 1 | step=3 \" Then post request \" load-test/request.j2.json \" with name \" template-request \" to endpoint \" /api/v1/test \" request.j2.json is a full Jinja2 template which will be rendered before the request is sent. The reason for this is that testdata variables can be used in the template, and these can change for each request. If request.j2.json contains the following: [ { % - f or n i n ra n ge(A t omicI nte gerI n creme nter .i te ms) % } { \"item\" : {{ n }}, \"name\" : \"item-{{ n }}\" } { % - i f n < A t omicI nte gerI n creme nter .i te ms - 1 % },{ % - e n di f % } { % - e n d f or % } ] Since the scenario has been setup to run for 3 iterations with 1 user and assumed that we run it locally, or distributed with one worker node, the scenario will run three times. The first post request to /api/v1/test will have the following payload: [ { \"item\" : 0 , \"name\" : \"item-0\" } ] The second post request: [ { \"item\" : 0 , \"name\" : \"item-0\" }, { \"item\" : 1 , \"name\" : \"item-1\" }, { \"item\" : 2 , \"name\" : \"item-2\" }, { \"item\" : 3 , \"name\" : \"item-3\" } ] The third post request: [ { \"item\" : 0 , \"name\" : \"item-0\" }, { \"item\" : 1 , \"name\" : \"item-1\" }, { \"item\" : 2 , \"name\" : \"item-2\" }, { \"item\" : 3 , \"name\" : \"item-3\" }, { \"item\" : 4 , \"name\" : \"item-4\" }, { \"item\" : 5 , \"name\" : \"item-5\" }, { \"item\" : 6 , \"name\" : \"item-6\" } ] Step expression Most step expressions also support templating for their variables, for example: And set context variable \" auth.user.username \" to \" $conf::backend.auth.user.username \" And set context variable \" auth.refresh_time \" to \" {{ AtomicIntegerIncrementer.refresh_time }} \" And repeat for \" {{ iterations * 0.25 }} \" And save statistics to \" influxdb://$conf::statistics.username:$conf::statistics.password@{{ influxdb_host }}/$conf::statistics.database \" And ask for value of variable \" initial_id \" And value for variable \" AtomicIntegerIncrementer.id1 \" is \" {{ initial_id }} \" And value for variable \" AtomicIntegerIncrementer.id2 \" is \" {{ initial_id }} \" Then put request with name \" example-{{ initial_id }} \" to \" /api/v{{ initial_id }}/test \" \"\"\" { \"test\": { \"value\": \"{{ initial_id }}\" } } \"\"\"","title":"Templating"},{"location":"usage/variables/templating/#templating","text":"grizzly has support for templating in both step expression variables (most) and request payload, with the templating backend Jinja2 .","title":"Templating"},{"location":"usage/variables/templating/#request-payload","text":"Request payload is treated as complete Jinja2 templates and has full support for any Jinja2 features. Request payload files must be stored in ./features/requests and are referenced in a feature file as a relative path to that directory. . \u2514\u2500\u2500 features \u251c\u2500\u2500 load-test.feature \u2514\u2500\u2500 requests \u2514\u2500\u2500 load-test \u2514\u2500\u2500 request.j2.json Consider that load-test.feature contains the following steps: Feature: templating example Background: common settings for all scenarios Given \" 1 \" user And spawn rate is \" 1 \" user per second And stop on first failure Scenario: example Given a user of type \" RestApi \" load testing \" https://localhost \" And repeat for \" 3 \" iterations And value for variable \" AtomicIntegerIncrementer.items \" is \" 1 | step=3 \" Then post request \" load-test/request.j2.json \" with name \" template-request \" to endpoint \" /api/v1/test \" request.j2.json is a full Jinja2 template which will be rendered before the request is sent. The reason for this is that testdata variables can be used in the template, and these can change for each request. If request.j2.json contains the following: [ { % - f or n i n ra n ge(A t omicI nte gerI n creme nter .i te ms) % } { \"item\" : {{ n }}, \"name\" : \"item-{{ n }}\" } { % - i f n < A t omicI nte gerI n creme nter .i te ms - 1 % },{ % - e n di f % } { % - e n d f or % } ] Since the scenario has been setup to run for 3 iterations with 1 user and assumed that we run it locally, or distributed with one worker node, the scenario will run three times. The first post request to /api/v1/test will have the following payload: [ { \"item\" : 0 , \"name\" : \"item-0\" } ] The second post request: [ { \"item\" : 0 , \"name\" : \"item-0\" }, { \"item\" : 1 , \"name\" : \"item-1\" }, { \"item\" : 2 , \"name\" : \"item-2\" }, { \"item\" : 3 , \"name\" : \"item-3\" } ] The third post request: [ { \"item\" : 0 , \"name\" : \"item-0\" }, { \"item\" : 1 , \"name\" : \"item-1\" }, { \"item\" : 2 , \"name\" : \"item-2\" }, { \"item\" : 3 , \"name\" : \"item-3\" }, { \"item\" : 4 , \"name\" : \"item-4\" }, { \"item\" : 5 , \"name\" : \"item-5\" }, { \"item\" : 6 , \"name\" : \"item-6\" } ]","title":"Request payload"},{"location":"usage/variables/templating/#step-expression","text":"Most step expressions also support templating for their variables, for example: And set context variable \" auth.user.username \" to \" $conf::backend.auth.user.username \" And set context variable \" auth.refresh_time \" to \" {{ AtomicIntegerIncrementer.refresh_time }} \" And repeat for \" {{ iterations * 0.25 }} \" And save statistics to \" influxdb://$conf::statistics.username:$conf::statistics.password@{{ influxdb_host }}/$conf::statistics.database \" And ask for value of variable \" initial_id \" And value for variable \" AtomicIntegerIncrementer.id1 \" is \" {{ initial_id }} \" And value for variable \" AtomicIntegerIncrementer.id2 \" is \" {{ initial_id }} \" Then put request with name \" example-{{ initial_id }} \" to \" /api/v{{ initial_id }}/test \" \"\"\" { \"test\": { \"value\": \"{{ initial_id }}\" } } \"\"\"","title":"Step expression"},{"location":"usage/variables/testdata/csv-row/","text":"grizzly.testdata.variables.csv_row This variable reads a CSV file and provides a new row from the CSV file each time it is accessed. The CSV files must have headers for each column, since these are used to reference the value. Format Value is the path, relative to requests/ , of an file ending with .csv . Arguments repeat bool (optional) - whether values should be reused, e.g. when reaching the end it should start from the beginning again (default: False ) random bool (optional) - if rows should be selected by random, instead of sequential from first to last (default: False ) Example requests/example.csv : username,password bob1,some-password alice1,some-other-password bob2,password And value of variable \" AtomicCsvRow.example \" is \" example.csv | random=False, repeat=True \" Then post request with name \" authenticate \" to endpoint \" /api/v1/authenticate \" \"\"\" { \"username\": \"{{ AtomicCsvRow.example.username }}\", \"password\": \"{{ AtomicCsvRow.example.password }}\" } \"\"\" First request the payload will be: { \"username\" : \"bob1\" , \"password\" : \"some-password\" } Second request: { \"username\" : \"alice1\" , \"password\" : \"some-other-password\" } etc.","title":"CSV Row"},{"location":"usage/variables/testdata/csv-row/#grizzlytestdatavariablescsv_row","text":"This variable reads a CSV file and provides a new row from the CSV file each time it is accessed. The CSV files must have headers for each column, since these are used to reference the value.","title":"grizzly.testdata.variables.csv_row"},{"location":"usage/variables/testdata/csv-row/#format","text":"Value is the path, relative to requests/ , of an file ending with .csv .","title":"Format"},{"location":"usage/variables/testdata/csv-row/#arguments","text":"repeat bool (optional) - whether values should be reused, e.g. when reaching the end it should start from the beginning again (default: False ) random bool (optional) - if rows should be selected by random, instead of sequential from first to last (default: False )","title":"Arguments"},{"location":"usage/variables/testdata/csv-row/#example","text":"requests/example.csv : username,password bob1,some-password alice1,some-other-password bob2,password And value of variable \" AtomicCsvRow.example \" is \" example.csv | random=False, repeat=True \" Then post request with name \" authenticate \" to endpoint \" /api/v1/authenticate \" \"\"\" { \"username\": \"{{ AtomicCsvRow.example.username }}\", \"password\": \"{{ AtomicCsvRow.example.password }}\" } \"\"\" First request the payload will be: { \"username\" : \"bob1\" , \"password\" : \"some-password\" } Second request: { \"username\" : \"alice1\" , \"password\" : \"some-other-password\" } etc.","title":"Example"},{"location":"usage/variables/testdata/date/","text":"grizzly.testdata.variables.date This variable is used to format and use dates. Format Initial value can, other than a parseable datetime string, be now . Each time the variable is accessed the value will represent that date and time at the time of access. Arguments format str - a python strftime format string , this argument is required timezone str (optional) - a valid timezone name Example And value of variable \" AtomicDate.arrival \" is \" now | format='%Y-%m-%dT%H:%M:%S.000Z', timezone=UTC \" This can then be used in a template: { \"arrival\" : \"{{ AtomicDate.arrival }}\" , \"location\" : \"Port of Shanghai\" }","title":"Date"},{"location":"usage/variables/testdata/date/#grizzlytestdatavariablesdate","text":"This variable is used to format and use dates.","title":"grizzly.testdata.variables.date"},{"location":"usage/variables/testdata/date/#format","text":"Initial value can, other than a parseable datetime string, be now . Each time the variable is accessed the value will represent that date and time at the time of access.","title":"Format"},{"location":"usage/variables/testdata/date/#arguments","text":"format str - a python strftime format string , this argument is required timezone str (optional) - a valid timezone name","title":"Arguments"},{"location":"usage/variables/testdata/date/#example","text":"And value of variable \" AtomicDate.arrival \" is \" now | format='%Y-%m-%dT%H:%M:%S.000Z', timezone=UTC \" This can then be used in a template: { \"arrival\" : \"{{ AtomicDate.arrival }}\" , \"location\" : \"Port of Shanghai\" }","title":"Example"},{"location":"usage/variables/testdata/directory-contents/","text":"grizzly.testdata.variables.directory_contents This variable provides a list of files in the specified directory. Format Relative path of a directory under requests/ . Arguments repeat bool (optional) - wether values should be reused, e.g. when reaching the end it should start from the beginning again (default: False ) random bool (optional) - if files should be selected by random, instead of sequential from first to last (default: False ) Example With the following directory structure: . \u2514\u2500\u2500 requests \u2514\u2500\u2500 files \u251c\u2500\u2500 file1.bin \u251c\u2500\u2500 file2.bin \u251c\u2500\u2500 file3.bin \u251c\u2500\u2500 file4.bin \u2514\u2500\u2500 file5.bin And value of variable \" AtomicDirectoryContents.files \" is \" files/ | repeat=True, random=False \" And put request \" {{ AtomicDirectoryContents.files }} \" with name \" put-file \" to endpoint \" /tmp \" First request will provide file1.bin , second file2.bin etc.","title":"Directory Contents"},{"location":"usage/variables/testdata/directory-contents/#grizzlytestdatavariablesdirectory_contents","text":"This variable provides a list of files in the specified directory.","title":"grizzly.testdata.variables.directory_contents"},{"location":"usage/variables/testdata/directory-contents/#format","text":"Relative path of a directory under requests/ .","title":"Format"},{"location":"usage/variables/testdata/directory-contents/#arguments","text":"repeat bool (optional) - wether values should be reused, e.g. when reaching the end it should start from the beginning again (default: False ) random bool (optional) - if files should be selected by random, instead of sequential from first to last (default: False )","title":"Arguments"},{"location":"usage/variables/testdata/directory-contents/#example","text":"With the following directory structure: . \u2514\u2500\u2500 requests \u2514\u2500\u2500 files \u251c\u2500\u2500 file1.bin \u251c\u2500\u2500 file2.bin \u251c\u2500\u2500 file3.bin \u251c\u2500\u2500 file4.bin \u2514\u2500\u2500 file5.bin And value of variable \" AtomicDirectoryContents.files \" is \" files/ | repeat=True, random=False \" And put request \" {{ AtomicDirectoryContents.files }} \" with name \" put-file \" to endpoint \" /tmp \" First request will provide file1.bin , second file2.bin etc.","title":"Example"},{"location":"usage/variables/testdata/integer-incrementer/","text":"grizzly.testdata.variables.integer_incrementer This variable provides an unique integer each time it is accessed. Useful to generate unique ID for each request. Format The first value of an integer that is going to be used. Arguments step int , (optional) - how much the value should increment each time (default 1 ) Example And value of variable \" AtomicIntegerIncrementer.unique_id \" is \" 100 | step=10 \" This can then be used in a template: { \"id\" : {{ A t omicI nte gerI n creme nter .u n ique_id }} } First request AtomicIntegerIncrementer.unique_id will be 100 , second 110 , third 120 etc.","title":"Integer incrementer"},{"location":"usage/variables/testdata/integer-incrementer/#grizzlytestdatavariablesinteger_incrementer","text":"This variable provides an unique integer each time it is accessed. Useful to generate unique ID for each request.","title":"grizzly.testdata.variables.integer_incrementer"},{"location":"usage/variables/testdata/integer-incrementer/#format","text":"The first value of an integer that is going to be used.","title":"Format"},{"location":"usage/variables/testdata/integer-incrementer/#arguments","text":"step int , (optional) - how much the value should increment each time (default 1 )","title":"Arguments"},{"location":"usage/variables/testdata/integer-incrementer/#example","text":"And value of variable \" AtomicIntegerIncrementer.unique_id \" is \" 100 | step=10 \" This can then be used in a template: { \"id\" : {{ A t omicI nte gerI n creme nter .u n ique_id }} } First request AtomicIntegerIncrementer.unique_id will be 100 , second 110 , third 120 etc.","title":"Example"},{"location":"usage/variables/testdata/random-integer/","text":"grizzly.testdata.variables.random_integer This variable provides an random integer between specified interval. Format Interval from which the integer should be generated from, in the format <min>..<max> . Arguments This variable does not have any arguments. Example And value of variable \" AtomicRandomInteger.weight \" is \" 10..30 \" This can then be used in a template: { \"weight_tons\" : {{ A t omicRa n domI nte ger.weigh t }} } AtomicRandomInteger.weight will then be anything between, and including, 10 and 30 .","title":"Random Integer"},{"location":"usage/variables/testdata/random-integer/#grizzlytestdatavariablesrandom_integer","text":"This variable provides an random integer between specified interval.","title":"grizzly.testdata.variables.random_integer"},{"location":"usage/variables/testdata/random-integer/#format","text":"Interval from which the integer should be generated from, in the format <min>..<max> .","title":"Format"},{"location":"usage/variables/testdata/random-integer/#arguments","text":"This variable does not have any arguments.","title":"Arguments"},{"location":"usage/variables/testdata/random-integer/#example","text":"And value of variable \" AtomicRandomInteger.weight \" is \" 10..30 \" This can then be used in a template: { \"weight_tons\" : {{ A t omicRa n domI nte ger.weigh t }} } AtomicRandomInteger.weight will then be anything between, and including, 10 and 30 .","title":"Example"},{"location":"usage/variables/testdata/random-string/","text":"grizzly.testdata.variables.random_string This variable generates a specified number of unique strings, based on a string format pattern. The list is pre-populated to ensure that each string is unique. Format Initial value is a string pattern specified with %s and %d . %s represents one ASCII letter %d represents one digit between 0 and 9 Parts of the string can be static, e.g. not random. Arguments count int (optional) - number of unique strings to generate (default: 1 ) upper bool (optional) - if the strings should be in upper case (default: False ) Example And value of variable \" AtomicRandomString.registration_plate_number \" is \" %s%sZ%d%d0 | upper=True, count=100 \" This can then be used in a template: { \"registration_plate_number\" : \"{{ AtomicRandomString.registration_plate_number }}\" } AtomicRandomString.registration_plate_number will then be a string in the format [A-Z][A-Z]Z[0-9][0-9]0 and there will be 100 unique values for disposal.","title":"Random String"},{"location":"usage/variables/testdata/random-string/#grizzlytestdatavariablesrandom_string","text":"This variable generates a specified number of unique strings, based on a string format pattern. The list is pre-populated to ensure that each string is unique.","title":"grizzly.testdata.variables.random_string"},{"location":"usage/variables/testdata/random-string/#format","text":"Initial value is a string pattern specified with %s and %d . %s represents one ASCII letter %d represents one digit between 0 and 9 Parts of the string can be static, e.g. not random.","title":"Format"},{"location":"usage/variables/testdata/random-string/#arguments","text":"count int (optional) - number of unique strings to generate (default: 1 ) upper bool (optional) - if the strings should be in upper case (default: False )","title":"Arguments"},{"location":"usage/variables/testdata/random-string/#example","text":"And value of variable \" AtomicRandomString.registration_plate_number \" is \" %s%sZ%d%d0 | upper=True, count=100 \" This can then be used in a template: { \"registration_plate_number\" : \"{{ AtomicRandomString.registration_plate_number }}\" } AtomicRandomString.registration_plate_number will then be a string in the format [A-Z][A-Z]Z[0-9][0-9]0 and there will be 100 unique values for disposal.","title":"Example"}]}